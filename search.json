[{"title":"15个必须掌握的 JavaScript 数组方法","url":"/2020/06/15%E4%B8%AA%E5%BF%85%E9%A1%BB%E6%8E%8C%E6%8F%A1%E7%9A%84JavaScript%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/","content":"在 JavaScript 中，数组是一个特殊的变量，用于存储不同的元素。它具有一些内置属性和方法，可用于根据需要添加，删除，迭代或操作数。并且了解 JavaScript 数组方法可以提升你的开发技能。\n在本文中，我们将介绍 15 种关于 JavaScript 的数组方法，这些方法可以帮助你正确地处理数据。\n\nsome()\nreduce()\nEvery()\nmap()\nflat()\nfilter()\nforEach()\nfindIndex()\nfind()\nsort()\nconcat()\nfill()\nincludes()\nreverse()\nflatMap()\n\nsome()此方法为参数传递的函数测试数组。如果有一个元素与测试元素匹配，则返回 true，否则返回 false。\n\nsome() 不会对空数组进行检测；some() 不会改变原始数组。\n\nconst myAwesomeArray = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;];myAwesomeArray.some(item =&gt; item === &quot;d&quot;);//-------&gt; Output : true\n\nreduce()此方法接收一个函数作为累加器。它为数组中的每个元素依次执行回调函数，不包括数组中被删除或者从未被赋值的元素。函数应用于累加器，数组中的每个值最后只返回一个值。\n\nreduce() 方法接受四个参数：初始值（上一次回调的返回值），当前元素值，当前索引，原数组。\n\nconst myAwesomeArray = [1, 2, 3, 4, 5];myAwesomeArray.reduce((total, value) =&gt; total * value);// 1 * 2 * 3 * 4 * 5//-------&gt; Output = 120\n\nEvery()此方法是对数组中每项运行给定函数，如果数组的每个元素都与测试匹配，则返回 true，反之则返回 false。\nconst myAwesomeArray = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;];myAwesomeArray.every(item =&gt; item === &quot;d&quot;);// -------&gt; Output : falseconst myAwesomeArray2 = [&quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;a&quot;];myAwesomeArray2.every(item =&gt; item === &quot;a&quot;);//-------&gt; Output : true\n\nmap()该方法返回一个新数组，数组中的元素为原始数组元素调用函数处理后的值。它按照原始数组元素顺序依次处理元素。\n\nmap() 不会对空数组进行检测；map() 不会改变原始数组。\n\nconst myAwesomeArray = [5, 4, 3, 2, 1];myAwesomeArray.map(x =&gt; x * x);//-------&gt; Output : 25//                  16//                  9//                  4//                  1\n\nflat()此方法创建一个新数组，其中包含子数组上的 holden 元素，并将其平整到新数组中。请注意，此方法只能进行一个级别的深度。\nconst myAwesomeArray = [[1, 2], [3, 4], 5];myAwesomeArray.flat();//-------&gt; Output : [1, 2, 3, 4, 5]\n\nfilter()该方法接收一个函数作为参数。并返回一个新数组，该数组包含该数组的所有元素，作为参数传递的过滤函数对其返回 true。\n\nfilter() 方法是对数据中的元素进行过滤，也就是说是不能修改原数组中的数据，只能读取原数组中的数据，callback 需要返回布尔值；为 true 的时候，对应的元素留下来；为 false 的时候，对应的元素过滤掉。\n\nconst myAwesomeArray = [   &#123; id: 1, name: &quot;john&quot; &#125;,     &#123; id: 2, name: &quot;Ali&quot; &#125;,     &#123; id: 3, name: &quot;Mass&quot; &#125;,     &#123; id: 4, name: &quot;Mass&quot; &#125;];myAwesomeArray.filter(element =&gt; element.name === &quot;Mass&quot;);//-------&gt; Output : 0:&#123;id: 3, name: &quot;Mass&quot;&#125;,//                  1:&#123;id: 4, name: &quot;Mass&quot;&#125;\n\nforEach()此方法用于调用数组的每个元素。并将元素传递给回调函数。\n\nforEach() 对于空数组是不会执行回调函数的。\n\nconst myAwesomeArray = [      &#123; id: 1, name: &quot;john&quot; &#125;,      &#123; id: 2, name: &quot;Ali&quot; &#125;,      &#123; id: 3, name: &quot;Mass&quot; &#125;];myAwesomeArray.forEach(element =&gt; console.log(element.name));//-------&gt; Output : john//                  Ali//                  Mass\n\nfindIndex()此方法返回传入一个测试条件（函数）符合条件的数组第一个元素位置。它为数组中的每个元素都调用一次函数执行，当数组中的元素在测试条件时返回 true 时, findIndex() 返回符合条件的元素的索引位置，之后的值不会再调用执行函数。如果没有符合条件的元素返回 -1。\n\nfindIndex() 对于空数组，函数是不会执行的， findIndex() 并没有改变数组的原始值。\n\nconst myAwesomeArray = [      &#123; id: 1, name: &quot;john&quot; &#125;,      &#123; id: 2, name: &quot;Ali&quot; &#125;,      &#123; id: 3, name: &quot;Mass&quot; &#125;];myAwesomeArray.findIndex(element =&gt; element.id === 3);// -------&gt; Output : 2myAwesomeArray.findIndex(element =&gt; element.id === 7);//-------&gt; Output : -1\n\nfind()此方法返回通过测试（函数内判断）的数组的第一个元素的值。find() 方法为数组中的每个元素都调用一次函数执行：当数组中的元素在测试条件时回 true 时, find() 返回符合条件的元素，之后的值不会再调用执行函数。如果没有符合条件的元素返回 undefined。\n\nfind() 对于空数组，函数是不会执行的；find() 并没有改变数组的原始值。\n\nconst myAwesomeArray = [      &#123; id: 1, name: &quot;john&quot; &#125;,      &#123; id: 2, name: &quot;Ali&quot; &#125;,      &#123; id: 3, name: &quot;Mass&quot; &#125;];myAwesomeArray.find(element =&gt; element.id === 3);// -------&gt; Output : &#123;id: 3, name: &quot;Mass&quot;&#125;myAwesomeArray.find(element =&gt; element.id === 7);//-------&gt; Output : undefined\n\nsort()此方法接收一个函数作为参数。它对数组的元素进行排序并返回它。也可以使用含有参数的 sort() 方法进行排序。\nconst myAwesomeArray = [5, 4, 3, 2, 1];// Sort from smallest to largestmyAwesomeArray.sort((a, b) =&gt; a - b);//  -------&gt; Output : [1, 2, 3, 4, 5]// Sort from largest to smallestmyAwesomeArray.sort((a, b) =&gt; b - a);//-------&gt; Output : [5, 4, 3, 2, 1]\n\nconcat()此方法用于连接两个或多个数组/值，它不会改变现有的数组。而仅仅返回被连接数组的一个新数组。\nconst myAwesomeArray = [1, 2, 3, 4, 5];const myAwesomeArray2 = [10, 20, 30, 40, 50];myAwesomeArray.concat(myAwesomeArray2);//-------&gt; Output : [1, 2, 3, 4, 5, 10, 20, 30, 40, 50]\n\nfill()此方法的作用是使用一个固定值来替换数组中的元素。该固定值可以是字母、数字、字符串、数组等等。它还有两个可选参数，表示填充起来的开始位置（默认为 0）与结束位置（默认为 array.length）。\n\nfill() 方法用于将一个固定值替换数组的元素。\n\nconst myAwesomeArray = [1, 2, 3, 4, 5];// The first argument  (0) is the value// The second argument (1) is the starting index// The third argument  (3) is the ending indexmyAwesomeArray.fill(0, 1, 3);//-------&gt; Output : [1, 0, 0, 4, 5]\n\nincludes()此方法用于判断字符串是否包含指定的子字符串。如果找到匹配的字符串则返回 true，否则返回 false。\n\nincludes() 方法区分大小写。\n\nconst myAwesomeArray = [1, 2, 3, 4, 5];myAwesomeArray.includes(3);// -------&gt; Output : truemyAwesomeArray.includes(8);// -------&gt; Output : false\n\nreverse()此方法用于颠倒数组中元素的顺序。第一个元素成为最后一个，最后一个元素将成为第一个。\nconst myAwesomeArray = [&quot;e&quot;, &quot;d&quot;, &quot;c&quot;, &quot;b&quot;, &quot;a&quot;];myAwesomeArray.reverse();// -------&gt; Output : [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;]\n\nflatMap()该方法将函数应用于数组的每个元素，然后将结果压缩为一个新数组。它在一个函数中结合了 flat() 和 map()。\nconst myAwesomeArray = [[1], [2], [3], [4], [5]];myAwesomeArray.flatMap(arr =&gt; arr * 10);//-------&gt; Output : [10, 20, 30, 40, 50]// With .flat() and .map()myAwesomeArray.flat().map(arr =&gt; arr * 10);//-------&gt; Output : [10, 20, 30, 40, 50]","categories":["前端"],"tags":["JavaScript","数组"]},{"title":"Angular Material Dialog 拖拽功能的实现","url":"/2019/06/Angular-Material-Dialog-%E6%8B%96%E6%8B%BD%E5%8A%9F%E8%83%BD%E7%9A%84%E5%AE%9E%E7%8E%B0/","content":"版本本案例使用的 Angular 7.x 版本，Material 7.x 版本，但不限于此版本。\n新建Angular指令新建指令命令：ng generate directive dialog-draggable\n\n\n指令中拖拽功能代码实现：\nimport &#123; Directive, HostListener, OnInit &#125; from &#x27;@angular/core&#x27;;import &#123; MatDialogContainer, MatDialogRef &#125; from &#x27;@angular/material&#x27;;import &#123; Subscription, fromEvent &#125; from &#x27;rxjs&#x27;;import &#123; takeUntil &#125; from &#x27;rxjs/operators&#x27;;export interface Position &#123;  x: number;  y: number;&#125;@Directive(&#123;  selector: &#x27;[dialog-draggable]&#x27;&#125;)export class DialogDraggableDirective implements OnInit &#123;  private _subscription: Subscription;  mouseStart: Position;  mouseDelta: Position;  offset: Position;  constructor(    private matDialogRef: MatDialogRef&lt;any&gt;,    private container: MatDialogContainer  ) &#123;  &#125;  ngOnInit() &#123;    this.offset = this._getOffset();    this._updatePosition(this.offset.y, this.offset.x);  &#125;  @HostListener(&#x27;mousedown&#x27;, [&#x27;$event&#x27;])  onMouseDown(event: MouseEvent) &#123;    this.mouseStart = &#123; x: event.pageX, y: event.pageY &#125;;    const mouseup$ = fromEvent(document, &#x27;mouseup&#x27;);    this._subscription = mouseup$.subscribe(() =&gt; this.onMouseup());    const mousemove$ = fromEvent(document, &#x27;mousemove&#x27;)      .pipe(takeUntil(mouseup$))      .subscribe((e: MouseEvent) =&gt; this.onMouseMove(e));    this._subscription.add(mousemove$);  &#125;  onMouseMove(event: MouseEvent) &#123;    this.mouseDelta = &#123; x: (event.pageX - this.mouseStart.x), y: (event.pageY - this.mouseStart.y) &#125;;    this._updatePosition(this.offset.y + this.mouseDelta.y, this.offset.x + this.mouseDelta.x);  &#125;  onMouseup() &#123;    if (this._subscription) &#123;      this._subscription.unsubscribe();      this._subscription = undefined;    &#125;    if (this.mouseDelta) &#123;      this.offset.x += this.mouseDelta.x;      this.offset.y += this.mouseDelta.y;    &#125;  &#125;  private _updatePosition(top: number, left: number) &#123;    this.matDialogRef.updatePosition(&#123;      top: top + &#x27;px&#x27;,      left: left + &#x27;px&#x27;    &#125;);  &#125;  private _getOffset(): Position &#123;    const box = this.container[&#x27;_elementRef&#x27;].nativeElement.getBoundingClientRect();    return &#123;      x: box.left + pageXOffset,      y: box.top + pageYOffset    &#125;;  &#125;&#125;\n\n在全局的CSS样式文件添加下面的CSS代码：\n[dialog-draggable] &#123;  margin: -24px -24px 20px -24px !important;  padding: 10px 24px;  background: #283593 !important;  color: #fff;  cursor: move;&#125;\n\n如何使用在Dialog组件中使用dialog-draggable指令即可实现窗口拖拽，如下\n&lt;h2 mat-dialog-title dialog-draggable&gt;  Angular Material Dialog Draggable&lt;/h2&gt;","categories":["Angular"],"tags":["Angular","Material"]},{"title":"CSS 元素垂直居中的几种常用方法","url":"/2018/02/CSS%E5%85%83%E7%B4%A0%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%E7%9A%84%E5%87%A0%E7%A7%8D%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/","content":"子绝父相子绝父相：子元素绝对定位，父元素相对定位。\n不知道子元素高度和父元素高度的情况.parentElement &#123;    position: relative;&#125;.childElement &#123;    position: absolute;    top: 50%;    transform: translateY(-50%);&#125;\n\n知道子元素高度和父元素高度的情况.parentElement &#123;    position: relative;&#125;.childElement &#123;    position: absolute;    top: 0;    bottom: 0;    left: 0;    right: 0;    margin: auto;&#125;\n\n\n子元素相对定位父元素设置了高度，而且父元素里面只有一个子元素，可使用子元素相对定位。\n.parentElement &#123;    height: xxpx;&#125;.childElement &#123;    position: relative;    top: 50%;    transform: translateY(-50%);&#125;\n\nCSS3 flex如果不考虑低版本浏览器兼容性，用CSS3的flex布局就非常简单咯。\n.parentElement &#123;    display: flex;    align-items: center;&#125;","categories":["前端"],"tags":["CSS","垂直居中"]},{"title":"ILS 官网上线啦","url":"/2020/10/ILS-%E5%AE%98%E7%BD%91%E4%B8%8A%E7%BA%BF%E5%95%A6/","content":"ILS 官网上线啦，网址：https://ils.xpoet.cn/ ，托管在 GitHub Pages，如遇加载缓慢等情况，牢记科学上网。\nILS 官网 将逐步完善主题配置文件 _config.yml 说明文档和图文教程，以及 Hexo 静态博客相关的各种经验和技巧分享。\n\n\n链接：\n\nILS 主题配置文件图文教程\n\nILS 代码贡献指南\n\n使用 Travis CI 自动部署 Hexo 静态博客\n\n\n","categories":["ILS"],"tags":["Hexo","ILS"]},{"title":"JS 常用的正则表达式汇总","url":"/2020/07/JS-%E5%B8%B8%E7%94%A8%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%87%E6%80%BB/","content":"此文收录我在开发过程中所用到的以及在各种业务场景下常用到的正则表达式，持续更新…\nJavaScript 正则表达式正则表达式（英语：Regular Expression，在代码中常简写为 regex、regexp 或 RE）使用单个字符串来描述、匹配一系列符合某个句法规则的字符串搜索模式。\n更多介绍，请参考：\n\nhttps://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions\nhttps://www.runoob.com/js/js-regexp.html\n\n语法&#x2F;正则表达式主体&#x2F;修饰符(可选)\n\neg:const RE &#x3D; &#x2F;xpoet&#x2F;i;解析：&#x2F;xpoet&#x2F;i 是一个正则表达式。xpoet 是一个正则表达式主体 (用于检索)。i 是一个修饰符 (搜索不区分大小写)。\n\n常用的匹配规则\n验证数字：^[0-9]*$。\n验证 n 位的数字：^\\d&#123;n&#125;$。\n验证至少 n 位数字：^\\d&#123;n,&#125;$。\n验证 m-n 位的数字：^\\d&#123;m,n&#125;$。\n验证零和非零开头的数字：^(0|[1-9][0-9]*)$。\n验证有两位小数的正实数：^[0-9]+(.[0-9]&#123;2&#125;)?$。\n验证有1-3位小数的正实数：^[0-9]+(.[0-9]&#123;1,3&#125;)?$。\n验证非零的正整数：^\\+?[1-9][0-9]*$。\n验证非零的负整数：^\\-[1-9][0-9]*$。\n验证非负整数（正整数 + 0）： ^\\d+$。\n验证非正整数（负整数 + 0）： ^((-\\d+)|(0+))$。\n验证长度为 3 的字符：^.&#123;3&#125;$。\n验证由 26 个英文字母组成的字符串：^[A-Za-z]+$。\n验证由26个大写英文字母组成的字符串：^[A-Z]+$。\n验证由26个小写英文字母组成的字符串：^[a-z]+$。\n验证由数字和26个英文字母组成的字符串：^[A-Za-z0-9]+$。\n验证由数字、26个英文字母或者下划线组成的字符串：^\\w+$。\n验证用户密码（格式为：以字母开头，长度在6-18之间，只能包含字符、数字和下划线）：^[a-zA-Z]\\w&#123;5,17&#125;$。\n验证是否含有 ^%&amp;&#39;,;=?$\\&quot; 等字符：[^%&amp;&#39;,;=?$\\x22]+。\n验证汉字：^[\\u4e00-\\u9fa5],&#123;0,&#125;$。\n验证Email地址：^\\w+[-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*$。\n验证InternetURL：^http://([\\w-]+\\.)+[\\w-]+(/[\\w-./?%&amp;=]*)?$ ；^[a-zA-z]+://(w+(-w+)*)(.(w+(-w+)*))*(?S*)?$。\n验证电话号码（格式为：XXXX-XXXXXXX，XXXX-XXXXXXXX，XXX-XXXXXXX，XXX-XXXXXXXX，XXXXXXX，XXXXXXXX）：^(\\(\\d&#123;3,4&#125;\\)|\\d&#123;3,4&#125;-)?\\d&#123;7,8&#125;$。\n验证身份证号（15位或18位数字）：^\\d&#123;15&#125;|\\d&#123;&#125;18$。\n验证一年的12个月（格式为：“01”-“09”和“1”“12”）：^(0?[1-9]|1[0-2])$。\n验证一个月的31天（格式为：01、09和1、31）：^((0?[1-9])|((1|2)[0-9])|30|31)$。\n整数：^-?\\d+$。\n非负浮点数（正浮点数 + 0）：^\\d+(\\.\\d+)?$。\n正浮点数：^(([0-9]+\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\.[0-9]+)|([0-9]*[1-9][0-9]*))$。\n非正浮点数（负浮点数 + 0）：^((-\\d+(\\.\\d+)?)|(0+(\\.0+)?))$。\n负浮点数：^(-(([0-9]+\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\.[0-9]+)|([0-9]*[1-9][0-9]*)))$。\n浮点数：^(-?\\d+)(\\.\\d+)?$。\n\n","categories":["前端"],"tags":["JS","正则表达式"]},{"title":"JavaScript 数据结构与算法学习笔记（专辑）","url":"/2020/07/JavaScript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%93%E8%BE%91%EF%BC%89/","content":"JavaScript 数据结构与算法学习笔记（专辑）是作者根据哔哩哔哩《coderwhy 的 JavaScript 数据结构与算法》视频教程整理而得，仅供大家查阅，欢迎指出错误。\n目录\n\nJavaScript 数据结构与算法（一）前言\nJavaScript 数据结构与算法（二）数组结构\nJavaScript 数据结构与算法（三）栈结构\nJavaScript 数据结构与算法（四）队列结构\nJavaScript 数据结构与算法（五）单向链表结构\n\n","categories":["算法专辑"],"tags":["JavaScript","数据结构","算法"]},{"title":"JavaScript 数据结构与算法（一）前言","url":"/2020/07/JavaScript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%80%EF%BC%89%E5%89%8D%E8%A8%80/","content":"什么是数据结构？数据结构的定义\n官方定义\n无\n\n民间定义\n\n“数据结构是数据对象，以及存在于该对象的实例和组成实例的数据元素之间的各种联系。这些联系可以通过定义相关的函数来给出。” — 《数据结构、算法与应用》\n“数据结构是 ADT（抽象数据类型 Abstract Data Type）的物理实现。” — 《数据结构与算法分析》\n“数据结构（data structure）是计算机中存储、组织数据的方式。通常情况下，精心选择的数据结构可以带来最优效率的算法。” —中文维基百科\n\n\n从自己角度认识\n在计算机中，存储和组织数据的方式。\n\n\n数据结构在生活中应用我们知道，计算机中数据量非常庞大，如何以高效的方式组织和存储呢?\n例如：一个庞大的图书馆中存放了大量的书籍，我们不仅仅要把书放进入，还应该在合适的时候能够取出来。\n图书摆放要使得两个相关操作方便实现：\n\n操作 1：新书怎么插入？\n操作 2：怎么找到某本指定的书？\n\n图书各种摆放方式：\n\n方法 1：随便放\n\n操作 1：哪里有空位放哪里。\n操作 2：找某本书，累死。\n\n\n方法 2：按照书名的拼音字母顺序排放\n\n操作 1：新进一本《阿 Q 正传》， 按照字母顺序找到位置，插入。\n操作 2：二分查找法。\n\n\n方法 3：把书架划分成几块区域，按照类别存放，类别中按照字母顺序\n\n操作 1：先定类别，二分查找确定位置，移出空位。\n操作 2：先定类别，再二分查找。\n\n\n\n结论：\n\n解决问题方法的效率，根据数据的组织方式有关。\n计算机中存储的数据量相对于图书馆的书籍来说数据量更大，数据更加多。\n以什么样的方式，来存储和组织我们的数据才能在使用数据时更加方便呢?\n这就是数据结构需要考虑的问题。\n\n常见的数据结构\n数组（Aarray）\n栈（Stack）\n链表（Linked List）\n图（Graph）\n散列表（Hash）\n队列（Queue）\n树（Tree）\n堆（Heap）\n\n\n注意：数据结构与算法与语言无关，常见的编程语言都有直接或间接的使用上述常见的数据结构。\n\n什么是算法？算法（Algorithm）的定义\n一个有限指令集，每条指令的描述不依赖于语言。\n接收一些输入（有些情况下不需要输入）。\n产生输出。\n一定在有限步骤之后终止。\n\n算法通俗理解\nAlgorithm 这个单词本意就是解决问题的办法/步骤逻辑。\n数据结构的实现，离不开算法。\n\n算法案例假如上海和杭州之间有一条高架线，高架线长度是 1,000,000 米，有一天高架线中有其中一米出现了故障，请你想出一种算法，可以快速定位到处问题的地方。\n\n线性查找\n\n从上海的起点开始一米一米的排查，最终一定能找到出问题的线段。\n但是如果线段在另一头，我们需要排查 1,000,000 次，这是最坏的情况，平均需要 500,000 次。\n\n\n二分查找\n\n从中间位置开始排查，看一下问题出在上海到中间位置，还是中间到杭州的位置。\n查找对应的问题后，再从中间位置分开，重新锁定一般的路程。\n最坏的情况，需要多少次可以排查完呢? 最坏的情况是 20 次就可以找到出问题的地方。\n怎么计算出来的呢? log(1000000, 2)，以 2 位底，1000000 的对数 ≈ 20。\n\n\n\n结论：你会发现，解决问题的办法有很多，但是好的算法对比于差的算法，效率天壤之别。\n","categories":["算法专辑"],"tags":["JavaScript","数据结构","算法"]},{"title":"JavaScript 数据结构与算法（三）栈结构","url":"/2020/07/JavaScript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%89%EF%BC%89%E6%A0%88%E7%BB%93%E6%9E%84/","content":"数组是一个线性结构，并且可以在数组的任意位置插入和删除元素。但是有时候，我们为了实现某些功能，必须对这种任意性加以限制。栈和队列就是比较常见的受限的线性结构。\n栈（stack）是一种运算受限的线性表：\n\nLIFO（last in first out）表示就是后进入的元素，第一个弹出栈空间。类似于自动餐托盘，最后放上的托盘，往往先把拿出去使用。\n其限制是仅允许在表的一端进行插入和删除运算。这一端被称为栈顶，相对地，把另一端称为栈底。\n向一个栈插入新元素又称作进栈、入栈或压栈，它是把新元素放到栈顶元素的上面，使之成为新的栈顶元素；\n从一个栈删除元素又称作出栈或退栈，它是把栈顶元素删除掉，使其相邻的元素成为新的栈顶元素。\n\n如下图所示：\n栈的特点：先进后出，后进先出。\n程序中的栈结构\n函数调用栈：A(B(C(D())))：即 A 函数中调用 B，B 调用 C，C 调用 D；在 A 执行的过程中会将 A 压入栈，随后 B 执行时 B 也被压入栈，函数 C 和 D 执行时也会被压入栈。所以当前栈的顺序为：A-&gt;B-&gt;C-&gt;D（栈顶）；函数 D 执行完之后，会弹出栈被释放，弹出栈的顺序为 D-&gt;C-&gt;B-&gt;A;\n\n递归：为什么没有停止条件的递归会造成栈溢出？比如函数 A 为递归函数，不断地调用自己（因为函数还没有执行完，不会把函数弹出栈），不停地把相同的函数 A 压入栈，最后造成栈溢出（Stack Overfloat）。\n\n\n练习题目：有 6 个元素 6，5，4，3，2，1 按顺序进栈，问下列哪一个不是合法的出栈顺序？\n\nA：5 4 3 6 1 2 （√）\nB：4 5 3 2 1 6 （√）\nC：3 4 6 5 2 1 （×）\nD：2 3 4 1 5 6 （√）\n\n题目所说的按顺序进栈指的不是一次性全部进栈，而是有进有出，进栈顺序为 6 -&gt; 5 -&gt; 4 -&gt; 3 -&gt; 2 -&gt; 1。\n解析：\n\nA 答案：65 进栈，5 出栈，4 进栈出栈，3 进栈出栈，6 出栈，21 进栈，1 出栈，2 出栈（整体入栈顺序符合 654321）。\nB 答案：654 进栈，4 出栈，5 出栈，3 进栈出栈，2 进栈出栈，1 进栈出栈，6 出栈（整体的入栈顺序符合 654321）。\nC 答案：6543 进栈，3 出栈，4 出栈，之后应该 5 出栈而不是 6，所以错误。\nD 答案：65432 进栈，2 出栈，3 出栈，4 出栈，1 进栈出栈，5 出栈，6 出栈。符合入栈顺序。\n\n栈结构实现栈常见的操作\npush()：添加一个新元素到栈顶位置。\npop()：移除栈顶的元素，同时返回被移除的元素。\npeek()：返回栈顶的元素，不对栈做任何修改（该方法不会移除栈顶的元素，仅仅返回它）。\nisEmpty()：如果栈里没有任何元素就返回 true，否则返回 false。\nsize()：返回栈里的元素个数。这个方法和数组的 length 属性类似。\ntoString()：将栈结构的内容以字符串的形式返回。\n\nJavaScript 代码实现栈结构// 使用 ES6 实现class Stack &#123;  items = [];  // push() 压栈操作，给栈中添加元素  push(item) &#123;    this.items.push(item);  &#125;  // pop() 出栈操作，从栈中取出元素，并返回取出的那个元素  pop() &#123;    return this.items.pop();  &#125;  // peek() 查看栈顶元素  peek() &#123;    return this.items[this.items.length - 1];  &#125;  // isEmpty() 判断栈是否为空  isEmpty() &#123;    return this.items.length === 0;  &#125;  // size() 获取栈中元素个数  size() &#123;    return this.items.length;  &#125;  // toString() 返回以字符串形式的栈内元素数据  toString() &#123;    let result = &quot;&quot;;    for (let item of this.items) &#123;      result += item + &quot; &quot;;    &#125;    return result;  &#125;&#125;\n\n测试栈结构const stack = new Stack();stack.push(1);stack.push(22);stack.push(333);stack.push(4444);console.log(stack.items); //--&gt; [1, 22, 333, 4444]console.log(stack.pop()); //--&gt; 444console.log(stack.pop()); //--&gt; 333console.log(stack.peek()); //--&gt; 22console.log(stack.isEmpty()); //--&gt; falseconsole.log(stack.size()); //--&gt; 2console.log(stack.toString()); //--&gt; 1 22\n\n栈结构的简单应用利用栈结构的特点封装十进制转换为二进制的函数。\n代码实现// 十进制转换成二进制function dec2bin(dec) &#123;  // new 一个 Stack，保存余数  const stack = new Stack();  // 当不确定循环次数时，使用 while 循环  while (dec &gt; 0) &#123;    // 除二取余法    stack.push(dec % 2); // 获取余数，放入栈中    dec = Math.floor(dec / 2);  &#125;  let binaryString = &quot;&quot;;  // 不断地从栈中取出元素（0 或 1），并拼接到一起。  while (!stack.isEmpty()) &#123;    binaryString += stack.pop();  &#125;  return binaryString;&#125;\n\n测试// 验证十进制转换二进制方法console.log(dec2bin(10)); //--&gt; 1010console.log(dec2bin(100)); //--&gt; 1100100\n","categories":["算法专辑"],"tags":["JavaScript","数据结构","算法","栈"]},{"title":"JavaScript 数据结构与算法（二）数组结构","url":"/2020/07/JavaScript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89%E6%95%B0%E7%BB%84%E7%BB%93%E6%9E%84/","content":"几乎所有的编程语言都原生支持数组类型，因为数组是最简单的内存数据结构。数组通常情况下用于存储一系列同一种数据类型的值。但在 JavaScript 里，数组中可以保存不同类型的值。但我们还是要遵守最佳实践，别这么做（大多数语言都没这个能力）。\n创建和初始化数组\nnew Array()const daysOfWeek = new Array(&#39;Sunday&#39;, &#39;Monday&#39;, &#39;Tuesday&#39;, &#39;Wednesday&#39;,&#39;Thursday&#39;, &#39;Friday&#39;, &#39;Saturday&#39;);\n\n[]const daysOfWeek = [&#39;Sunday&#39;, &#39;Monday&#39;, &#39;Tuesday&#39;, &#39;Wednesday&#39;, &#39;Thursday&#39;, &#39;Friday&#39;, &#39;Saturday&#39;];\n\n\n数组常见操作添加元素\n添加一个元素到数组的最后位置 array.push(item)\n在数组首位插入一个元素 array.unshift(item)\n在指定索引位置插入元素 array.splice(index, 0, item)splice() 第二个参数为 0 时，表示插入数据。let myArray = [1, 2, 3];// 在 索引 0 的位置，插入 AmyArray.splice(0, 0, &quot;A&quot;);console.log(myArray); //--&gt; [&#x27;A&#x27;, 1, 2, 3]\n\n\n\n删除元素\n删除数组最后的元素 array.pop(item)\n删除数组首位的元素 array.shift(item)\n删除指定索引位置的元素 array.splice(start, number)例如：let myArray2 = [1, 2, 3, 4, 5];// 删除索引 4 位置起，2 个元素myArray2.splice(4, 2);console.log(myArray2); //--&gt; [1, 2, 3]\n\n\n\n修改元素\n修改指定索引位置的元素 array.splice(index, 1, item)let myArray3 = [1, 2, 3, 4, 5, 6];// 修改 索引 1 的位置的元素为 AAmyArray2.splice(1, 1, &quot;AA&quot;);console.log(myArray3); //--&gt; [1, &quot;AA&quot;, 3, 4, 5, 6]\n修改指定索引位置的几个元素 array.splice(index, number, item)let myArray4 = [1, 2, 3, 4, 5, 6, 7];// 在 索引 2 的位置起，修改两个元素为 AA BBmyArray2.splice(2, 2, &quot;AA&quot;, &quot;BB&quot;);console.log(myArray3); //--&gt; [1, 2, &quot;AA&quot;, &quot;BB&quot;, 5, 6, 7]\n\n\n","categories":["算法专辑"],"tags":["JavaScript","数组","数据结构","算法"]},{"title":"JavaScript 数据结构与算法（四）队列结构","url":"/2020/07/JavaScript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E5%9B%9B%EF%BC%89%E9%98%9F%E5%88%97%E7%BB%93%E6%9E%84/","content":"认识队列队列（Queue）是一种运算受限的线性表，特点：先进先出。(FIFO：First In First Out)\n受限之处：\n\n只允许在表的前端（front）进行删除操作。\n在表的后端（rear）进行插入操作。\n\n生活中类似队列结构的场景：\n\n排队,，比如在电影院，商场，甚至是厕所排队。\n优先排队的人，优先处理。 (买票、结账、WC)。\n\n\n队列图解\n队列在程序中的应用\n打印队列：计算机打印多个文件的时候，需要排队打印。\n线程队列：当开启多线程时，当新开启的线程所需的资源不足时就先放入线程队列，等待 CPU 处理。\n\n队列的实现队列的实现和栈一样，有两种方案：\n\n基于数组实现。\n基于链表实现。\n\n队列常见的操作\nenqueue(element)：向队列尾部添加一个（或多个）新的项。\ndequeue()：移除队列的第一（即排在队列最前面的）项，并返回被移除的元素。\nfront()：返回队列中的第一个元素——最先被添加，也将是最先被移除的元素。队列不做任何变动（不移除元素，只返回元素信息与 Stack 类的 peek 方法非常类似）。\nisEmpty()：如果队列中不包含任何元素，返回 true，否则返回 false。\nsize()：返回队列包含的元素个数，与数组的 length 属性类似。\ntoString()：将队列中的内容，转成字符串形式。\n\n代码实现// 使用 ES6 实现class Queue &#123;  items = [];  // enqueue() 入队，将元素加入到队列中  enqueue(item) &#123;    this.items.push(item);  &#125;  // dequeue() 出队，从队列中删除前端元素，返回删除的元素  dequeue() &#123;    return this.items.shift();  &#125;  // front() 查看队列的前端元素  front() &#123;    return this.items[0];  &#125;  // isEmpty() 查看队列是否为空  isEmpty() &#123;    return this.items.length === 0;  &#125;  // size() 查看队列中元素的个数  size() &#123;    return this.items.length;  &#125;  toString() &#123;    let result = &quot;&quot;;    for (let item of this.items) &#123;      result += item + &quot; &quot;;    &#125;    return result;  &#125;&#125;\n\n测试代码const queue = new Queue();// 入队操作queue.enqueue(&quot;a&quot;);queue.enqueue(&quot;b&quot;);queue.enqueue(&quot;c&quot;);queue.enqueue(&quot;d&quot;);console.log(queue.items); //--&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]// 出队操作（先进先出）queue.dequeue();queue.dequeue();console.log(queue.items); //--&gt; [&quot;c&quot;, &quot;d&quot;]// 查看队头的元素console.log(queue.front()); //--&gt; cconsole.log(queue.isEmpty()); //--&gt; falseconsole.log(queue.size()); //--&gt; 2console.log(queue.toString()); //--&gt; c d\n\n队列的应用使用队列实现小游戏：击鼓传花。\n分析：传入一组数据集合和设定的数字 number，循环遍历数组内元素，遍历到的元素为指定数字 number 时将该元素删除，直至数组剩下一个元素。\n代码实现function passGame(nameList, number) &#123;  // 1、new 一个 Queue 对象  const queue = new Queue();  // 2、将 nameList 里面的每一个元素入队  for (const name of nameList) &#123;    queue.enqueue(name);  &#125;  // 3、开始数数  // 队列中只剩下 1 个元素时就停止数数  while (queue.size() &gt; 1) &#123;    // 不是 number 时，重新加入到队尾    // 是 number 时，将其删除    for (let i = 0; i &lt; number - 1; i++) &#123;      // number 数字之前的人重新放入到队尾（即把队头删除的元素，重新加入到队列中）      queue.enqueue(queue.dequeue());    &#125;    // number 对应这个人，直接从队列中删除    // 由于队列没有像数组一样的下标值不能直接取到某一元素，    // 所以采用，把 number 前面的 number - 1 个元素先删除后添加到队列末尾，    // 这样第 number 个元素就排到了队列的最前面，可以直接使用 dequeue 方法进行删除    queue.dequeue();  &#125;  // 4、获取最后剩下的那个人  const endName = queue.front();  // 5、返回这个人在原数组中对应的索引  return nameList.indexOf(endName);&#125;\n\n测试代码const names = [&quot;lily&quot;, &quot;lucy&quot;, &quot;tom&quot;, &quot;tony&quot;, &quot;jack&quot;];const targetIndex = passGame(names, 4);console.log(&quot;击鼓传花&quot;, names[targetIndex]); //--&gt; lily\n\n优先队列优先级队列主要考虑的问题：\n\n每个元素不再只是一个数据，还包含数据的优先级。\n在添加数据过程中，根据优先级放入到正确位置。\n\n优先队列的实现代码实现class PriorityQueue &#123;  items = [];  // 内部类   QueueElement = class &#123;    constructor(element, priority) &#123;      this.element = element;      this.priority = priority;    &#125;  &#125;;  // enqueue() 入队，将元素按优先级加入到队列中  enqueue(element, priority) &#123;    // 根据传入的元素，创建 QueueElement 对象    const queueElement = new this.QueueElement(element, priority);    // 判断队列是否为空    if (this.isEmpty()) &#123;      // 如果为空，不用判断优先级，直接添加      this.items.push(queueElement);    &#125; else &#123;      // 定义一个变量记录是否成功添加了新元素      let added = false;      for (let i = 0; i &lt; this.items.length; i++) &#123;        // 让新插入的元素进行优先级比较，priority 值越小，优先级越大        if (queueElement.priority &lt; this.items[i].priority) &#123;          // 在指定的位置插入元素          this.items.splice(i, 0, queueElement);          added = true;          break;        &#125;      &#125;      // 如果遍历完所有元素，优先级都大于新插入的元素，就将新插入的元素插入到最后      if (!added) &#123;        this.items.push(queueElement);      &#125;    &#125;  &#125;  // dequeue() 出队，从队列中删除前端元素，返回删除的元素  dequeue() &#123;    return this.items.shift();  &#125;  // front() 查看队列的前端元素  front() &#123;    return this.items[0];  &#125;  // isEmpty() 查看队列是否为空  isEmpty() &#123;    return this.items.length === 0;  &#125;  // size() 查看队列中元素的个数  size() &#123;    return this.items.length;  &#125;  toString() &#123;    let result = &quot;&quot;;    for (let item of this.items) &#123;      result += item.element + &quot;-&quot; + item.priority + &quot; &quot;;    &#125;    return result;  &#125;&#125;\n\n测试代码const priorityQueue = new PriorityQueue();// 入队priorityQueue.enqueue(&quot;A&quot;, 10);priorityQueue.enqueue(&quot;B&quot;, 15);priorityQueue.enqueue(&quot;C&quot;, 11);priorityQueue.enqueue(&quot;D&quot;, 20);priorityQueue.enqueue(&quot;E&quot;, 18);console.log(priorityQueue.items);//--&gt; output:// QueueElement &#123;element: &quot;A&quot;, priority: 10&#125;// QueueElement &#123;element: &quot;C&quot;, priority: 11&#125;// QueueElement &#123;element: &quot;B&quot;, priority: 15&#125;// QueueElement &#123;element: &quot;E&quot;, priority: 18&#125;// QueueElement &#123;element: &quot;D&quot;, priority: 20&#125;// 出队priorityQueue.dequeue();priorityQueue.dequeue();console.log(priorityQueue.items);//--&gt; output:// QueueElement &#123;element: &quot;B&quot;, priority: 15&#125;// QueueElement &#123;element: &quot;E&quot;, priority: 18&#125;// QueueElement &#123;element: &quot;D&quot;, priority: 20&#125;console.log(priorityQueue.isEmpty()); //--&gt; falseconsole.log(priorityQueue.size()); //--&gt; 3console.log(priorityQueue.toString()); //--&gt; B-15 E-18 D-20\n\n数组、栈和队列图解\n","categories":["算法专辑"],"tags":["JavaScript","数据结构","算法","队列"]},{"title":"Vue 项目动态修改 DOM 的 CSS 伪类","url":"/2020/11/Vue-%E9%A1%B9%E7%9B%AE%E5%8A%A8%E6%80%81%E4%BF%AE%E6%94%B9-DOM-%E7%9A%84-CSS-%E4%BC%AA%E7%B1%BB/","content":"在 Vue 项目中，如何动态修改某个 DOM 元素的 CSS 伪类？实现方法非常简单，其原理是使用 CSS3 的 var() 函数和 -- 变量。\n以下列代码为例，实现动态修改 class 为 demo 的 div 元素鼠标悬浮时的背景颜色：\n\ntemplate 中，绑定一个 -- 变量 --hover-background-color。\n\nscript 中，定义一个变量 hoverBackgroundColor，用以动态背景颜色。\n\nstyle 中，background 的值用 var(--hover-background-color) 表示。\n\n\n&lt;template&gt;  &lt;div    class=&quot;demo&quot;    :style=&quot;&#123;                &#x27;--hover-background-color&#x27;: hoverBackgroundColor            &#125;&quot;  &gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;  export default &#123;    data() &#123;      return &#123;        hoverBackgroundColor: &quot;#ccc&quot;,      &#125;;    &#125;,  &#125;;&lt;/script&gt;&lt;style&gt;  .demo:hover &#123;    background: var(--hover-background-color);  &#125;&lt;/style&gt;\n","categories":["前端"],"tags":["Vue","CSS 伪类"]},{"title":"使用ES6新特性实现数组去重","url":"/2018/01/es6-array-eliminate-redundancy/","content":"数组去重，对于前端开发者来说家常便饭的事，更是初学者必须掌握的知识，面试经常会考。\n数组去重相关的方法，网上已有很多，大多使用了ES6以前的方法，本文对于不作赘述。但随着各大浏览器对ES6的支持性越来越好，以及ES6新特性深入人心，更何况作为一名前端工程师，我们应该顺应时代潮流，推动JavaScript发展，所以，尽情地拥抱ES6吧。\n本文讲解使用ES6新特性实现数组去重的一种新方法，代码及其简短又高效。  \nJavaScript代码：/** @param arr 传入的参数：带有重复项的数组* */Array.from(new Set(arr));\n\n\n\n例子：/** @param oldArr 带有重复项的旧数组* @param newArr 去除重复项之后的新数组* */let oldArr = [1, 1, 1, 2, 3, 2, 4, 4, 4, 9, 9, 0, 0, NaN, NaN];let newArr = Array.from(new Set(oldArr));console.log(newArr);  // [1, 2, 3, 4, 9, 0, NaN]\n\n分析：Set对象Set对象允许存储任何类型的唯一值，无论是原始值或者是对象引用。它可以是任何类型的单个值的集合。Set中的元素只会出现一次，即Set中的元素是唯一的。语法：new Set([iterable]);参数：iterable，如果传递一个可迭代对象(包括 Array，Map，Set，String，TypedArray，arguments 对象等等)，它的所有元素将被添加到新的 Set中。如果不指定此参数或其值为null，则新的Set为空。\nSet对象例子let testArr = [0, 1, 1, 2, 3, 3, 3, 3, 4, NaN, NaN, undefined, undefined];let setTestArr = new Set(testArr);console.log(setTestArr);  // Set(6) &#123;1, 2, 3, 4, NaN, undefined&#125;\n\nfrom对象Array.from()方法从一个类似数组或可迭代的对象(包括 Array，Map，Set，String，TypedArray，arguments 对象等等) 中创建一个新的数组实例。\nfrom对象例子let testArr = [0, 1, 1, 2, 3, 3, 3, 3, 4, NaN, NaN, undefined, undefined];let setTestArr = new Set(testArr);console.log(setTestArr);  // &#123;1, 2, 3, 4, NaN, undefined&#125;let newArr = Array.from(setTestArr);console.log(newArr);  // [1, 2, 3, 4, NaN, undefined]\n\n使用ES6实现数组去重，就是如此简单，快去试试吧~\n","categories":["前端"],"tags":["数组去重","ES6"]},{"title":"macOS 使用 Navicat 连接 MySQL 数据库","url":"/2019/07/macOS%E4%BD%BF%E7%94%A8Navicat%E8%BF%9E%E6%8E%A5MySQL%E6%95%B0%E6%8D%AE%E5%BA%93/","content":"安装 MySQL\n从 MySQL 官网下载安装包进行安装，链接：https://www.mysql.com/downloads/\n\n使用终端命令安装，需提前安装 Homebrew。\n\n安装 Homebrew/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;\n安装 MySQLbrew install mysql\n打开 MySQL 服务\n\n\n在终端使用命令 mysql --version 查看 MySQL 版本，出现具体的版本号，表示 MySQL 成功安装，如下图。\nmysql --version\n\n\n\n在终端使用命令 bash mysql.server start 来打开 MySQL 服务。如下图，表示 MySQL 服务启动成功。\nbash mysql.server start\n\n\n\n\n登录 MySQLMySQL 默认的 root 账户不带密码，使用命令 mysql -uroot 可直接登录，如下图，表示登录成功。\nmysql -uroot\n\n\n因为默认的 root 账户不带密码，安全起见，我们给 root 账户设置密码。（例如设置密码：123456）\nset password for &#39;root&#39;@&#39;localhost&#39;&#x3D;&#39;123456&#39;;\n\n\n密码设置成功后，再次登录时需要输入密码，如下命令。\nmysql -uroot -p&#39;123456&#39;\n\n\nNavicat 连接 MySQL点击 Navicat Premium 左上角的”连接”，选择” MySQL “，新建一个 MySQL 连接，参数如下，默认端口 3306。\n注：\n\n可使用命令 lsof -i:3306 查看 3306 端口是否被占用。\n如果点击”测试连接“发现连接不上，出现报错信息：2059 - Authentication plugin &#39;caching_sha2_password&#39; cannot be loaded: dlopen(../Frameworks/caching_.......错误原因是因为 MySQL 5.7 版本之后，默认验证方式由原来的 mysql_native_password 改成了 caching_sha2_password。只需把验证方式修改成原来的，就能连接上了。修改方法：登录 MySQL，执行命令：ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED WITH mysql_native_password BY &#39;123456&#39;;\n\n\n","categories":["数据库"],"tags":["MySQL","Navicat"]},{"title":"macOS 配置多个 Git 账户的 SSH-Key","url":"/2018/07/macOS%E9%85%8D%E7%BD%AE%E5%A4%9A%E4%B8%AAGit%E8%B4%A6%E6%88%B7%E7%9A%84SSH-Key/","content":"准备工作请确保在你的Mac上已安装Git。安装Git请参考：传送门在终端输入命令$ git --version， 能打印出具体的版本号，表示Git正确安装。\n开始配置本文以配置GitHub和GitLab为案例，将生成两对公共/私有rsa密钥对，rsa_github 和 rsa_gitlab。\n在本地创建SSH-Key1、打开终端，$ cd ~，进入到当前用户目录下。  \n2、使用命令$ ssh-keygen -t rsa -C &quot;i@itpoet.cn&quot;生成公共/私有rsa密钥对。此时会看到终端提示输入要保存密钥的文件名，为了做区分，我们给文件名加个后缀，本例第一个rsa密钥对：rsa_github。接着会看到终端提示输入密码，敲两次 Enter回车键 则不需要密码。最终在 .ssh 文件夹 里生成 rsa_github_ 和 _rsa_github.pub 两个文件，如图：注意：在 第2步 执行完后，如果用户目录下没有生成 .ssh 文件夹 ，那我们需要手动创建。  \n$ cd ~$ mkdir .ssh$ cd .ssh\n成功创建完 .ssh 文件夹 之后，再执行 第2步 操作。  \n3、创建本例的第二个rsa密钥对，rsa_gitlab。 \n$ cd .ssh$ ssh-keygen -t rsa -C &quot;a@itpoet.cn&quot;\n如图：  \n4、为ssh添加config配置文件，在 .ssh文件夹 下，新建config文件。  \n$ cd ~/.ssh$ touch config\nconfig文件创建好之后，\b将其内容\b修改为：\nHost github.com  User itPoet_github  IdentityFile ~&#x2F;.ssh&#x2F;rsa_githubHost gitlab.com  User itPoet_gitlab  IdentityFile ~&#x2F;.ssh&#x2F;rsa_gitlab\n\n5、配置 .gitconfig 文件。使用如下命令将会在用户目录下自动创建 .gitconfig 文件。\n$ cd ~$ git config --global user.name &quot;itPoet_github&quot;$ git config --global user.email &quot;i@itpoet.cn&quot;\n\n注意：在 第4步 执行完后，如果用户目录下没有生成 .gitconfig 文件 ，那我们需要手动创建。\n$ cd ~$ touch .gitconfig\n最后将.gitconfig文件的内容修改为：\n[user]    name &#x3D; itPoet_github    email &#x3D; i@itpoet.cn[user]    name &#x3D; itPoet_gitlab    email &#x3D; a@itpoet.cn\n在对应的Git网站\b添加SSH密钥设置1、 GitHubsettings –&gt; SSH and GPG keys –&gt; New SSH Key\b打开 rsa_github.pub，将里面的内容复制到 Key 输入框中，如图：如图：  \n2、 GitLabProfile –&gt; SSH keys\b打开 rsa_gitlab.pub，将里面的内容复制到 Key 输入框中，如图：如图：  \n至此，在Mac下配置多个Git账户的SSH-Key参考教程也完成，同理，我们还可以配置Coding、码云等。现在让我们来体验使用SSH\b提交代码吧~~\n","categories":["技术教程"],"tags":["Mac","Git","SSH-Key"]},{"title":"基于Node.js搭建Socket聊天室","url":"/2018/02/nodejs-build-socket-chartroom/","content":"前言可以毫不夸张的说，Node.js的出现带动了整个前端界的繁荣发展，自此进入百花齐放，百家争鸣的时代。时至今天，我们能用Node.js实现很多依靠传统服务器端编程语言才能实现的事，甚至更加简便、更加高效。本案例使用Node.js的net模块，建立服务端与客户端的Socket连接，简单实现了客户端广播消息通信和点对点通信。\n项目结构server.js 服务端项目下的server.js是服务端的执行文件，用于创建服务端的Socket服务，监听指定端口；接收客户端传过来的数据，解析数据并按照数据中附带的协议进行广播消息通信或点对点通信。具体代码如下：\n// Socket聊天室 - server 服务端const net = require(&#x27;net&#x27;);// 定义clients（键值对集合），用于存储所有的客户端连接，通过用户名去索引客户端socketlet clients = &#123;&#125;;let server = net.createServer((socket) =&gt; &#123;    // 客户端登入    function signin(clientDataContent) &#123;        clientDataContent = JSON.parse(clientDataContent);        let username = clientDataContent.from;        // 如果clients（客户端 socket 集合）中有1个以上的成员，就广播通知所有人谁谁上线了，除了他本身        if (Object.keys(clients).length) &#123;            let onlineNotice = &#123;  // 组成上线通知消息数据格式                protocol: &#x27;online&#x27;,                online: username,                onlineCount: Object.keys(clients).length + 1            &#125;;            // 遍历 clients ，给除了自身的所有客户端发送消息            for (let username in clients) &#123;                if (clients.hasOwnProperty(username)) &#123;                    let noticeClient = clients[username];                    noticeClient.write(JSON.stringify(onlineNotice));                &#125;            &#125;        &#125;        // 将新连接的客户端socket存储于clients        clients[username] = socket;        // 服务端打印上线提示消息        console.log(`欢迎 $&#123;socket.remoteAddress&#125;:$&#123;socket.remotePort&#125;【$&#123;username&#125;】，加入聊天室，当前在线：$&#123;Object.keys(clients).length&#125;`);    &#125;    // 广播消息通信    function broadcast(clientDataContent) &#123;        // 广播出去消息数据格式 json        let sendClientData = JSON.parse(clientDataContent);        // 遍历clients对象（for in），给所有的客户端socket广播消息        for (let username in clients) &#123;            if (clients.hasOwnProperty(username)) &#123;                let client = clients[username];                client.write(JSON.stringify(sendClientData));            &#125;        &#125;    &#125;    // p2p 点对点通信    function p2p(clientDataContent) &#123;        let p2pClientData = JSON.parse(clientDataContent);        // 给指定的客户端发送消息        clients[p2pClientData.to].write(JSON.stringify(p2pClientData));    &#125;    // 给每一个连接服务端的客户端socket注册data事件    socket.on(&#x27;data&#x27;, (chunk) =&gt; &#123;        try &#123;            // 对客户端传过来的数据chunk（json数据）进行序列化            let clientDataContent = chunk.toString().trim();            // 获取协议            let protocol = JSON.parse(clientDataContent).protocol;            switch (protocol) &#123;                case &#x27;signin&#x27;:                    signin(clientDataContent);                    break;                case &#x27;broadcast&#x27;:                    broadcast(clientDataContent);                    break;                case &#x27;p2p&#x27;:                    p2p(clientDataContent);                    break;                default:                    socket.write(&#x27;错误！未能识别的通信协议！&#x27;);                    break;            &#125;        &#125; catch (error) &#123;            socket.write(&#x27;出现错误了哦~&#x27;);            throw error;        &#125;    &#125;);    // 给每一个连接服务端的客户端socket注册error事件，如果连接中断，则触发此事件    socket.on(&#x27;error&#x27;, (error) =&gt; &#123;        // 在客户端对象中，将连接中断的那个客户端删除        let deletekey = null;        // 遍历clients对象，找到下线的socket，并将其删除        for (let username in clients) &#123;            if (clients.hasOwnProperty(username)) &#123;                let client = clients[username];                if (socket === client) deletekey = username;            &#125;        &#125;        delete clients[deletekey];        // 广播通知所有人，谁谁下线了        let offlineNotice = &#123;  // 组成下线通知消息数据格式            protocol: &#x27;offline&#x27;,            offline: deletekey,            onlineCount: Object.keys(clients).length        &#125;;        for (let username in clients) &#123;            if (clients.hasOwnProperty(username)) &#123;                let noticeClient = clients[username];                noticeClient.write(JSON.stringify(offlineNotice));            &#125;        &#125;        // server 消息        console.log(`$&#123;deletekey&#125; 下线了，当前在线：$&#123;Object.keys(clients).length&#125;`);    &#125;);&#125;);// 监听指定端口let port = 2018;server.listen(port, (error) =&gt; &#123;    if (error) &#123;        console.log(`$&#123;port&#125;端口被占用！`);    &#125; else &#123;        console.log(`服务器端正常启动，正在监听$&#123;port&#125;端口`);    &#125;&#125;);\n\n\nclient.js 客户端项目下的client.js是客户端的执行文件，用于创建客户端的Socket服务。将用户输入的内容按特定的格式组成数据结构发给服务端，同时打印出服务端指定的内容。具体代码如下：\n// Socket聊天室 - 客户端 clientconst net = require(&#x27;net&#x27;);const readline = require(&#x27;readline&#x27;);const rl = readline.createInterface(process.stdin, process.stdout);rl.question(&#x27;请输入聊天昵称：&#x27;, (nickname) =&gt; &#123;    nickname = nickname.trim();    if (!nickname) &#123;        throw new Error(&#x27;昵称不能为空！&#x27;);    &#125;    // 创建与服务端的连接    // 设置正确的服务端的ip地址和端口    let server = net.connect(&#123;port: 2018, host: &#x27;127.0.0.1&#x27;&#125;, () =&gt; &#123;        // 登入操作        let user = &#123;            protocol: &#x27;signin&#x27;,            from: nickname        &#125;;        // 往服务端传送数据        server.write(JSON.stringify(user));        console.log(`【系统通知】已成功加入聊天室，尽情畅聊吧~`);        // 监听服务端发送过来的数据        server.on(&#x27;data&#x27;, (chunk) =&gt; &#123;            try &#123;                let serverDataContent = JSON.parse(chunk.toString().trim());                let protocol = serverDataContent.protocol;                switch (protocol) &#123;                    case &#x27;online&#x27;:                        console.log(`\\n【系统通知】欢迎：$&#123;serverDataContent.online&#125;，加入聊天室，当前在线人数：$&#123;serverDataContent.onlineCount&#125;\\n`);                        rl.prompt();                        break;                    case &#x27;offline&#x27;:                        console.log(`\\n【系统通知】$&#123;serverDataContent.offline&#125;下线了，当前在线人数：$&#123;serverDataContent.onlineCount&#125;\\n`);                        rl.prompt();                        break;                    case &#x27;broadcast&#x27;:                        console.log(`\\n[@所有人] $&#123;serverDataContent.from&#125;&gt; $&#123;serverDataContent.message&#125;\\n`);                        rl.prompt();                        break;                    case &#x27;p2p&#x27;:                        console.log(`\\n[@$&#123;serverDataContent.to&#125;] $&#123;serverDataContent.from&#125;&gt; $&#123;serverDataContent.message&#125;\\n`);                        rl.prompt();                        break;                    default:                        server.write(&#x27;错误！未能识别的通信协议！&#x27;);                        break;                &#125;            &#125; catch (error) &#123;                server.write(&#x27;出现错误了哦~&#x27;);                throw error;            &#125;        &#125;);        rl.setPrompt(nickname + &#x27;&gt; &#x27;);  // 此时没有写入控制台        rl.prompt(); // 写入控制台        // 输入一行内容敲回车        rl.on(&#x27;line&#x27;, (line) =&gt; &#123;            line = line.toString().trim();            // 内容： user1:我只跟你说话  表示，客户端用户只跟user1通信            // 根据客户端用户输入的内容按“:”分割成两部分            let arrString = line.split(&#x27;:&#x27;);            let sendServerData = null;            // 组成往服务端发送的数据格式            if (arrString.length === 2) &#123;                // 点对点                sendServerData = &#123;                    protocol: &#x27;p2p&#x27;,                    from: nickname,                    to: arrString[0],                    message: arrString[1]                &#125;;            &#125; else &#123;                // 广播消息                sendServerData = &#123;                    protocol: &#x27;broadcast&#x27;,                    from: nickname,                    message: line                &#125;;            &#125;            // 往服务端发送数据            server.write(JSON.stringify(sendServerData));            rl.prompt(); // 写入控制台        &#125;);        rl.on(&#x27;close&#x27;, () =&gt; &#123;        &#125;);    &#125;);&#125;);\n\n实现功能目前已实现：客户端广播消息通信、点对点通信。\n项目使用\n启动服务端，$ node server.js\n启动第一个客户端，$ node client.js\n启动第二个客户端，$ node client.js\n……\n\n演示视频\n项目下载本案例源代码托管于GitHub，下载：传送门\n","categories":["前端"],"tags":["Node.js"]},{"title":"不朽的失眠","url":"/2018/03/%E4%B8%8D%E6%9C%BD%E7%9A%84%E5%A4%B1%E7%9C%A0/","content":"\n记得第一次见这篇文章出现在初中的语文书上，确确实实引起了我的共鸣，自此念念不忘，忽然感觉此刻很应景，收录此文。\n\n他落榜了！一千二百年前。榜纸那么大那么长，然而，就是没有他的名字。啊！竟单单容不下他的名字“张继”那两个字。  \n考中的人，姓名一笔一划写在榜单上，天下皆知。奇怪的是，在他的感觉里，考不上，才更是天下皆知，这件事，令他羞惭沮丧。\n离开京城吧！议好了价，他踏上小舟。本来预期的情节不是这样的，本来也许有插花游街、马蹄轻疾的风流，有衣锦还乡、袍笏加身的荣耀。然而，寒窗十年，虽有他的悬梁刺股，琼林宴上，却并没有他的一角席次。\n船行似风。\n江枫如火，在岸上举着冷冷的爝焰，这天黄昏，船，来到了苏州。但，这美丽的古城，对张继而言，也无非是另一个触动愁情的地方。\n如果说白天有什么该做的事，对一个读书人而言，就是读书吧！夜晚呢？夜晚该睡觉以便养足精神第二天再读。然而，今夜是一个忧伤的夜晚。今夜，在异乡，在江畔，在秋冷雁高的季节，容许一个落魄的士子放肆他的忧伤。江水，可以无限度地收纳古往今来一切不顺遂之人的泪水。\n这样的夜晚，残酷地坐着，亲自听自己的心正被什么东西啮食而一分一分消失的声音。并且眼睁睁地看自己的生命如劲风中的残灯，所有的力气都花在抗拒，油快尽了，微火每一刹那都可能熄灭。然而，可恨的是，终其一生，它都不曾华美灿烂过啊！\n江水睡了，船睡了，船家睡了，岸上的人也睡了。惟有他，张继，睡不着。夜愈深，愈清醒，清醒如败叶落余的枯树，似梁燕飞去的空巢。\n起先，是睡眠排拒的他。(也罢，这半生，不是处处都遭排拒吗？)而后，是他在赌气，好，无眠就无眠，长夜独醒，就干脆彻底来为自已验伤，有何不可？\n月亮西斜了，一副意兴阑珊的样子。有乌啼，粗嗄嘶哑，是乌鸦。那月亮被它一声声叫得更黯淡了。江岸上，想已霜结千草。夜空里，星子亦如清霜，一粒粒零落凄绝。\n在须角在眉梢，他感觉，似乎也森然生凉，那阴阴不怀好意的凉气啊，正等待凝成早秋的霜花，来贴缀他惨淡少年的容颜。\n江上渔火二三，他们在干什么？在捕鱼吧？或者，虾？他们也会有撒空网的时候吗？世路艰辛啊！即使潇洒的捕鱼的，也不免投身在风波里吧？然而，能辛苦工作，也是一种幸福吧！今夜，月自光其光，霜自冷其冷，安心的人在安眠，工作的人去工作。只有我张继，是天不管地不收的一个，是既没有权利去工作，也没福气去睡眠的一个……\n钟声响了，这奇怪的深夜的寒山寺钟声。一般寺庙，都是暮鼓晨钟，寒山寺庙敲“夜半钟”，用以惊世。钟声贴着水面传来，在别人，那声音只是睡梦中模糊的衬底音乐。在他，却一记一记都撞击在心坎上，正中要害。钟声那么美丽，但钟声自己到底是痛还是不痛呢？既然失眠，他推枕而起，摸黑写下“枫桥夜泊”四字。然后，就把其余二十八字照抄下来。我说“照抄”，是因为那二十八个字在他心底已像白墙上的黑字一样分明凸显：\n月落乌啼霜满天，江枫渔火对愁眠。\n姑苏城外寒山寺，夜半钟声到客船。\n感谢上苍，如果没有落第的张继，诗的历史上便少了一首好诗，我们的某一种心情，就没有人来为我们一语道破。\n一千二百年过去了，那张长长的榜单上（就是张继挤不进去的那纸金榜）曾经出现过的状元是谁？哈！管他是谁。真正被记得的名字是“落第者张继”。有人会记得那一届状元披红游街的盛景吗？不！我们只记得秋夜的客船上那个失意的人，以及他那场不朽的失眠。\n","categories":["文章收录"],"tags":["枫桥夜泊"]},{"title":"中文文案排版指北","url":"/2020/05/%E4%B8%AD%E6%96%87%E6%96%87%E6%A1%88%E6%8E%92%E7%89%88%E6%8C%87%E5%8C%97/","content":"统一中文文案、排版的相关用法，降低团队成员之间的沟通成本，增强网站气质。\n空格「有研究显示，打字的时候不喜欢在中文和英文之间加空格的人，感情路都走得很辛苦，有七成的比例会在 34 岁的时候跟自己不爱的人结婚，而其余三成的人最后只能把遗产留给自己的猫。毕竟爱情跟书写都需要适时地留白。\n与大家共勉之。」——vinta/paranoid-auto-spacing\n\n\n中英文之间需要增加空格正确：\n\n在 LeanCloud 上，数据存储是围绕 AVObject 进行的。\n\n错误：\n\n在LeanCloud上，数据存储是围绕AVObject进行的。\n在 LeanCloud上，数据存储是围绕AVObject 进行的。\n\n完整的正确用法：\n\n在 LeanCloud 上，数据存储是围绕 AVObject 进行的。每个 AVObject 都包含了与 JSON 兼容的 key-value 对应的数据。数据是 schema-free 的，你不需要在每个 AVObject 上提前指定存在哪些键，只要直接设定对应的 key-value 即可。\n\n例外：「豆瓣FM」等产品名词，按照官方所定义的格式书写。\n中文与数字之间需要增加空格正确：\n\n今天出去买菜花了 5000 元。\n\n错误：\n\n今天出去买菜花了 5000元。\n今天出去买菜花了5000元。\n\n数字与单位之间需要增加空格正确：\n\n我家的光纤入屋宽带有 10 Gbps，SSD 一共有 20 TB\n\n错误：\n\n我家的光纤入屋宽带有 10Gbps，SSD 一共有 20TB\n\n例外：度 / 百分比与数字之间不需要增加空格：\n正确：\n\n今天是 233° 的高温。\n新 MacBook Pro 有 15% 的 CPU 性能提升。\n\n错误：\n\n今天是 233 ° 的高温。\n新 MacBook Pro 有 15 % 的 CPU 性能提升。\n\n全角标点与其他字符之间不加空格正确：\n\n刚刚买了一部 iPhone，好开心！\n\n错误：\n\n刚刚买了一部 iPhone ，好开心！\n刚刚买了一部 iPhone， 好开心！\n\n用 text-spacing 来挽救？CSS Text Module Level 4 的 text-spacing 和 Microsoft 的 -ms-text-autospace 可以实现自动为中英文之间增加空白。不过目前并未普及，另外在其他应用场景，例如 macOS、iOS、Windows 等用户介面目前并不存在这个特性，所以请继续保持随手加空格的习惯。\n标点符号不重复使用标点符号正确：\n\n德国队竟然战胜了巴西队！\n她竟然对你说「喵」？！\n\n错误：\n\n德国队竟然战胜了巴西队！！\n德国队竟然战胜了巴西队！！！！！！！！\n她竟然对你说「喵」？？！！\n她竟然对你说「喵」？！？！？？！！\n\n全角和半角不明白什么是全角（全形）与半角（半形）符号？请查看维基百科词条『全形和半形』。\n使用全角中文标点正确：\n\n嗨！你知道嘛？今天前台的小妹跟我说「喵」了哎！\n核磁共振成像（NMRI）是什么原理都不知道？JFGI！\n\n错误：\n\n嗨! 你知道嘛? 今天前台的小妹跟我说 “喵” 了哎！\n嗨!你知道嘛?今天前台的小妹跟我说”喵”了哎！\n核磁共振成像 (NMRI) 是什么原理都不知道? JFGI!\n核磁共振成像(NMRI)是什么原理都不知道?JFGI!\n\n数字使用半角字符正确：\n\n这个蛋糕只卖 1000 元。\n\n错误：\n\n这个蛋糕只卖 １０００ 元。\n\n例外：在设计稿、宣传海报中如出现极少量数字的情形时，为方便文字对齐，是可以使用全形数字的。\n遇到完整的英文整句、特殊名词，其内容使用半角标点正确：\n\n贾伯斯那句话是怎么说的？「Stay hungry, stay foolish.」\n推荐你阅读《Hackers &amp; Painters: Big Ideas from the Computer Age》，非常的有趣。\n\n错误：\n\n贾伯斯那句话是怎么说的？「Stay hungry，stay foolish。」\n推荐你阅读《Hackers＆Painters：Big Ideas from the Computer Age》，非常的有趣。\n\n名词专有名词使用正确的大小写大小写相关用法原属于英文书写范畴，不属于本 wiki 讨论内容，在这里只对部分易错用法进行简述。\n正确：\n\n使用 GitHub 登录\n我们的客户有 GitHub、Foursquare、Microsoft Corporation、Google、Facebook, Inc.。\n\n错误：\n\n使用 github 登录\n使用 GITHUB 登录\n使用 Github 登录\n使用 gitHub 登录\n使用 gｲんĤЦ8 登录\n我们的客户有 github、foursquare、microsoft corporation、google、facebook, inc.。\n我们的客户有 GITHUB、FOURSQUARE、MICROSOFT CORPORATION、GOOGLE、FACEBOOK, INC.。\n我们的客户有 Github、FourSquare、MicroSoft Corporation、Google、FaceBook, Inc.。\n我们的客户有 gitHub、fourSquare、microSoft Corporation、google、faceBook, Inc.。\n我们的客户有 gｲんĤЦ8、ｷouЯƧquﾑгє、๓เςг๏ร๏Ŧt ς๏гק๏гคtเ๏ภn、900913、ƒ4ᄃëв๏๏к, IПᄃ.。\n\n注意：当网页中需要配合整体视觉风格而出现全部大写／小写的情形，HTML 中请使用标淮的大小写规范进行书写；并通过 text-transform: uppercase;／text-transform: lowercase; 对表现形式进行定义。\n不要使用不地道的缩写正确：\n\n我们需要一位熟悉 JavaScript、HTML5，至少理解一种框架（如 Backbone.js、AngularJS、React 等）的前端开发者。\n\n错误：\n\n我们需要一位熟悉 Js、h5，至少理解一种框架（如 backbone、angular、RJS 等）的 FED。\n\n争议以下用法略带有个人色彩，即：无论是否遵循下述规则，从语法的角度来讲都是正确的。\n链接之间增加空格用法：\n\n请 提交一个 issue 并分配给相关同事。\n访问我们网站的最新动态，请 点击这里 进行订阅！\n\n对比用法：\n\n请提交一个 issue并分配给相关同事。\n访问我们网站的最新动态，请点击这里进行订阅！\n\n简体中文使用直角引号用法：\n\n「老师，『有条不紊』的『紊』是什么意思？」\n\n对比用法：\n\n“老师，‘有条不紊’的‘紊’是什么意思？”\n\n工具\n\n\n仓库\n语言\n\n\n\nvinta/paranoid-auto-spacing\nJavaScript\n\n\nhuei90/pangu.node\nNode.js\n\n\nhuacnlee/auto-correct\nRuby\n\n\nsparanoid/space-lover\nPHP (WordPress)\n\n\nnauxliu/auto-correct\nPHP\n\n\njxlwqq/chinese-typesetting\nPHP\n\n\nhotoo/pangu.vim\nVim\n\n\nsparanoid/grunt-auto-spacing\nNode.js (Grunt)\n\n\nhjiang/scripts/add-space-between-latin-and-cjk\nPython\n\n\nhustcc/hint\nPython\n\n\nstudygolang/autocorrect\nGo\n\n\n谁在这样做？\n\n\n网站\n文案\nUGC\n\n\n\nApple 中国\n是\nN/A\n\n\nApple 香港\n是\nN/A\n\n\nApple 台湾\n是\nN/A\n\n\nMicrosoft 中国\n是\nN/A\n\n\nMicrosoft 香港\n是\nN/A\n\n\nMicrosoft 台湾\n是\nN/A\n\n\nLeanCloud\n是\nN/A\n\n\nV2EX\n是\n是\n\n\nApple4us\n是\nN/A\n\n\nRuby China\n是\n标题达成\n\n\nPHPHub\n是\n标题达成\n\n\n少数派\n是\nN/A\n\n\n参考文献\nGuidelines for Using Capital Letters - ThoughtCo.\nLetter case - Wikipedia\nPunctuation - Oxford Dictionaries\nPunctuation - The Purdue OWL\nHow to Use English Punctuation Correctly - wikiHow\n格式 - openSUSE\n全形和半形 - 维基百科\n引号 - 维基百科\n疑问惊叹号 - 维基百科\n\n注：本文转载 https://github.com/sparanoid/chinese-copywriting-guidelines\n","categories":["技术教程"],"tags":["文案排版"]},{"title":"使用gulp搭建前端自动化工作流环境（简易版）","url":"/2017/11/%E4%BD%BF%E7%94%A8Gulp%E6%90%AD%E5%BB%BA%E5%89%8D%E7%AB%AF%E8%87%AA%E5%8A%A8%E5%8C%96%E5%B7%A5%E4%BD%9C%E6%B5%81%EF%BC%88%E7%AE%80%E6%98%93%E7%89%88%EF%BC%89/","content":"\n本文通过简单且实用的案例，讲解使用 gulp 搭建前端自动化工作流环境详细步骤，带领大家快速入门。\n\n什么是 gulp？来自官网的简介：Automate and enhance your workflow. gulp is a toolkit for automating painful or time-consuming tasks in your development workflow, so you can stop messing around and build something.\n大致意思是讲 gulp 是一款自动化构建工具，可用于增强你的开发工作流程，提高工作效率！前端界的友友们，这个工具可不要错过了哟~\n\ngulp 官网\ngulp 中文网\n\ngulp 优点\n易于使用 通过代码优于配置的策略，gulp 让简单的任务简单，复杂的任务可管理。\n构建快速 利用 Node.js 流的威力，你可以快速构建项目并减少频繁的 IO 操作。\n插件高质 gulp 严格的插件指南确保插件如你期望的那样简洁高质得工作。\n易于学习 通过最少的 API，掌握 gulp 毫不费力，构建工作尽在掌握：如同一系列流管道。\n\n准备工作gulp 依赖 Node.js，参考本教程的朋友们，请先在本地环境安装好 Node.js，并确认 Node.js、npm 可正常使用。\n步骤第一步 新建项目根文件夹(例：gulp-demo)，并在项目根目录下使用 npm 安装必要的包$ npm install gulp gulp-less gulp-concat gulp-cssnano gulp-uglify gulp-htmlmin browser-sync --save-dev\n\n本案例使用的 gulp 插件介绍：\n\ngulp-less 将 less 编译成 css\ngulp-concat 将多个 JavaScript 合并\ngulp-cssnano css 压缩\ngulp-uglify JavaScript 压缩并混淆\ngulp-htmlmin html 压缩\nbrowser-sync 多浏览器同步操作\n\n第二步 在项目根文件夹(例：gulp-demo)下创建相关的文件结构src [gulp 编译之前的源文件]\ncss 我们在此处编写 css 文件\nimg 我们在此处放置图片文件\njs 我们在此处编写 css 文件\nindex1.html\nindex2.html\n…….\n\nnode_modules通过 npm 安装的包及其依赖包的库，自动生成文件夹。\ngulpfile.jsgulp 的入口文件，我们在此处编写相关任务代码。\ndist [gulp 编译之后的文件，即我们最终要得到文件]\ncss\nimg\njs\nindex.html\n\n第三步 在 gulpfile.js 文件里编写具体的任务代码载入所需要的模块&quot;use strict&quot;; // 启用JavaScript严格模式var gulp = require(&quot;gulp&quot;);var less = require(&quot;gulp-less&quot;);var cssnano = require(&quot;gulp-cssnano&quot;);var concat = require(&quot;gulp-concat&quot;);var uglify = require(&quot;gulp-uglify&quot;);var htmlmin = require(&quot;gulp-htmlmin&quot;);var browserSync = require(&quot;browser-sync&quot;);\n\nless 编译、压缩// 定义LESS编译、压缩的任务：cssgulp.task(&quot;css&quot;, function () &#123;  gulp    .src([&quot;src/css/*.less&quot;, &quot;!src/css/_*.less&quot;])    .pipe(less())    .pipe(cssnano())    .pipe(gulp.dest(&quot;dist/css&quot;))    .pipe(      browserSync.reload(&#123;        stream: true,      &#125;)    );&#125;);\n\nJavaScript 合并、压缩、混淆// 定义多个JavaScript文件合并、压缩混淆的任务：jsgulp.task(&quot;js&quot;, function () &#123;  gulp    .src(&quot;src/js/*.js&quot;)    .pipe(concat(&quot;index.js&quot;)) // JS合并之后，文件命名为index.js    .pipe(uglify()) // JS压缩混淆    .pipe(gulp.dest(&quot;dist/js&quot;))    .pipe(      browserSync.reload(&#123;        stream: true,      &#125;)    );&#125;);\n\n将 src 文件夹下 img 图片复制到 dist 文件夹下 img// 定义image复制的任务：imggulp.task(&quot;img&quot;, function () &#123;  gulp    .src(&quot;src/img/*.*&quot;)    .pipe(gulp.dest(&quot;dist/img&quot;))    .pipe(      browserSync.reload(&#123;        stream: true,      &#125;)    );&#125;);\n\nhtml 代码压缩// 定义HTML压缩的任务：htmlgulp.task(&quot;html&quot;, function () &#123;  gulp    .src(&quot;src/*.html&quot;)    .pipe(htmlmin(&#123; collapseWhitespace: true &#125;))    .pipe(gulp.dest(&quot;dist&quot;))    .pipe(      browserSync.reload(&#123;        stream: true,      &#125;)    );&#125;);\n\n多浏览器同步操作，开启 gulp 监视文件变动// 定义浏览器同步操作服务的任务：browserSyncgulp.task(&quot;browserSync&quot;, function () &#123;  browserSync(    &#123;      server: &#123;        baseDir: [&quot;dist&quot;],      &#125;,    &#125;,    function (err, bs) &#123;      console.log(bs.options.getIn([&quot;urls&quot;, &quot;local&quot;]));    &#125;  );  // 开启gulp监视  gulp.watch(&quot;src/css/*.less&quot;, [&quot;css&quot;]); // less文件改动时，执行css任务  gulp.watch(&quot;src/js/*.js&quot;, [&quot;js&quot;]); // js文件改动时，执行js任务  gulp.watch(&quot;src/img/*.*&quot;, [&quot;img&quot;]); // image文件改动时，执行img任务  gulp.watch(&quot;src/*.html&quot;, [&quot;html&quot;]); // html文件改动时，执行html任务&#125;);\n\n使用\n1 $ gulp css LESS 编译 压缩 合并\n2 $ gulp js JavaScript 合并 压缩 混淆\n3 $ gulp img image 复制\n4 $ gulp html HTML 压缩\n5 $ gulp browserSync 多浏览器同步操作，gulp 监视 JS/CSS/HTML 文件改变\n\n点击此处，下载本案例源代码\n","categories":["前端"],"tags":["Gulp","前端自动化"]},{"title":"再见，也许就是再也不见","url":"/2018/04/%E5%86%8D%E8%A7%81%EF%BC%8C%E4%B9%9F%E8%AE%B8%E5%B0%B1%E6%98%AF%E5%86%8D%E4%B9%9F%E4%B8%8D%E8%A7%81/","content":"","categories":["散文集"],"tags":["散文","再见"]},{"title":"利用时间戳和随机数生成一个不重复的字符串","url":"/2018/11/%E5%88%A9%E7%94%A8%E6%97%B6%E9%97%B4%E6%88%B3%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%94%9F%E6%88%90%E4%B8%80%E4%B8%AA%E4%B8%8D%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/","content":"JavaScript 或 TypeScript 巧妙利用时间戳和随机数生成一个不重复的字符串，可作为 UUID 使用，此方法非常简单高效。\n/** * JavaScript 版本 * @param randomLength 截取随机数的长度 * @return String 不重复的字符串（uuid） */export const getUuid = (randomLength) =&gt; &#123;  return Number(Math.random().toString().substr(2, randomLength) + Date.now()).toString(36);&#125;;// getUuid(5) -&gt; 2l5w9z6sqvg0\n\n/** * TypeScript 版本 * @param randomLength&#123;number&#125; 截取随机数的长度 * @return &#123;string&#125; 不重复的字符串（uuid） */export const getUuid = (randomLength: number = 5): string =&gt; &#123;  return Number(Math.random().toString().substr(2, randomLength) + Date.now()).toString(36);&#125;;// getUuid(5) -&gt; 2l5w9z6sqvg0\n\n","categories":["前端"],"tags":["JS","TS","UUID"]},{"title":"千呼万唤始出来，Hexo 主题 ILS 正式发布","url":"/2020/04/%E5%8D%83%E5%91%BC%E4%B8%87%E5%94%A4%E5%A7%8B%E5%87%BA%E6%9D%A5%EF%BC%8CHexo%E4%B8%BB%E9%A2%98ILS%E6%AD%A3%E5%BC%8F%E5%8F%91%E5%B8%83/","content":"如你所见，ILS 界面设计十分简洁、清爽，但功能齐全、不失优雅，这正是 ILS 的开发理念。也曾尝试过花里胡哨，发现不仅配置繁琐、容易审美疲劳，而且背驰了写博客的初衷，记录生活、展示文字，应该才是搭建博客网站的最终追求，为此 ILS 应运而生。简约轻快、突出内容、化繁为简、配置简单、长期维护，如果你也喜欢或认可这些主题特点，一起来探索吧~\n关于主题名 “ILS” 的由来：在主题开发之初，作者想到的几个名字都被已被用，词穷，后来干脆将名字取自 “I Like Simple「我喜欢简单」” 首字母，就是这么简单。\n\n\n同时，非常欢迎感兴趣的同学 Pull Request 加入到该主题的开发中（成为该项目的贡献者），按你的意愿来打磨 ILS。\nFeatures 功能特性Completed 已完成\n 恰到好处的留白，简约大气。\n 响应式设计，适配多种终端。\n 日间/夜间模式自由切换。\n 多种代码高亮方案。\n 语言国际化，支持中/英文。\n 内置多款评论插件。\n 支持全站文章搜索。\n 支持文章顶置。\n 代码块一键复制。\n TOC 目录结构。\n RSS 订阅。\n 网站 UV 和 PV 统计。\n 文章阅读次数统计。\n 文章字数统计。\n 文章阅读时长统计。\n 页面滚动进度条提示。\n 一键快速回到顶部。\n 无 jQuery，代码精简。\n\nUnfinished 未完成\n 图片懒加载\n 文章点赞功能\n 大图查看器\n 文章版权信息\n 在线更改字体和字号\n 打赏功能\n ……\n\nGet start 快速开始在开始使用主题之前，强烈建议你先阅读 「Easy Hexo 团队」撰写的 Hexo 教程！链接：https://easyhexo.com/\nInstall 安装\n使用 Git SSH\ngit clone --depth=1 git@github.com:XPoet/hexo-theme-ils.git themes/ils\n\n该方式获取的是 Master 分支最新代码，包含该主题最新的功能，但无法保证完全稳定。\n\n下载 Release 版本\n点击此处进入该主题 Releases 版本下载页面 请优先下载最新版本，下载完成后解压到 Hexo 博客目录的 themes 文件夹里面并重命名为 ils。\n\n\nEnable 启用Modify theme setting in _config.yml to ils.修改 Hexo 根目录下的 _config.yml 配置文件，将 theme 设置为 ils 。\ntheme: ils\n\nUpdate 更新\n使用 Git SSHcd themes/ilsgit pull\n下载 主题最新 Release 版本 。\n\nHow to use 如何使用Configuration 配置以下是主题配置文件的详细说明，建议多看几遍，并且对照着来修改自己的配置文件，边修改边查看界面效果。\n如遇到无法解决的问题，可以给我提 Issues 。\n# ---------------------------------------------------------------------------------------# Theme basic info (please don&#x27;t change)# 主题基本信息（请勿改动）# ---------------------------------------------------------------------------------------theme_info:  name: ILS  version: 2.0.3  author: XPoet  repository: https://github.com/XPoet/hexo-theme-ils# ---------------------------------------------------------------------------------------# Theme style settings# 主题样式设置# ---------------------------------------------------------------------------------------style:  # Theme primary color  # 主颜色，修改为自己喜欢的颜色即可，支持 rgb、十六进制格式。  # 建议使用 Web 安全色，https://www.bootcss.com/p/websafecolors/  primary_color: &quot;#0066CC&quot;  # favicon  # 网站图标，把 &quot;/source/images/&quot; 目录下的 &quot;favicon.png&quot;，换成自己的图片即可。  favicon: images/favicon.png  # avatar  # 头像图片，把 &quot;/source/images/&quot; 目录下的 &quot;avatar.png&quot;，换成自己的图片即可。  avatar: images/avatar.png# ---------------------------------------------------------------------------------------# Navigation menu# 导航菜单# 如需新增导航页，请按下面格式填写，同时需要创建相对应的 Hexo 页面。# 如何新增页面，请参考下面的教程：“Add page 添加页面”。# ---------------------------------------------------------------------------------------menu:  Home: /  Archives: /archives  # Categories: /categories  # Tags: /tags  # Links: /links  # About: /about  # ...# ---------------------------------------------------------------------------------------# RSS# Dependencies: hexo-generator-feed# See: https://github.com/hexojs/hexo-generator-feed# RSS 订阅，如需启用，请先安装 Hexo 插件：hexo-generator-feed。# 具体步骤，参考下面的教程：“RSS 订阅”。# ---------------------------------------------------------------------------------------rss:  enable: false# ---------------------------------------------------------------------------------------# Comment plugin# 评论插件# 主题内置了 Valine 和 Gitalk，只能使用其中一款。# ---------------------------------------------------------------------------------------comments:  # Valine  # See: https://github.com/xCss/Valine  # 如何使用 Valine，请参考官方教程：https://github.com/xCss/Valine  # 获取必要的参数，在下面填写。  valine:    enable: false    appid: # your leancloud application appid    appkey: # your leancloud application appkey    meta: # comment input meta, type: Array, values: [&#x27;nick&#x27;,&#x27;mail&#x27;,&#x27;link&#x27;]    placeholder: # your placeholder  # Gitalk  # See: https://github.com/gitalk/gitalk  # 如何使用 Gitalk，请参考官方教程：https://github.com/gitalk/gitalk  # 获取必要的参数，在下面填写。  gitalk:    enable: false    github_id: # GitHub repo owner    repository: # Repository name to store issues    client_id: # GitHub Application Client ID    client_secret: # GitHub Application Client Secret# ---------------------------------------------------------------------------------------# Website count# 网站计数# ---------------------------------------------------------------------------------------website_count:  # busuanzi  # See: http://ibruce.info/2015/04/04/busuanzi/  # 主题内置“不蒜子”计数，无需额外配置，选择你要开启的计数项即可。  # site_uv 访问人数计数  # site_pv 总访问量计数  # page_pv 文章阅读量计数  busuanzi_count:    enable: false    site_uv: false    site_pv: false    page_pv: false# ---------------------------------------------------------------------------------------# Local Search# Dependencies: hexo-generator-searchdb# See: https://github.com/theme-next/hexo-generator-searchdb# 本地搜索，如需启用，请先安装 Hexo 插件：hexo-generator-searchdb。# 具体步骤，参考下面的教程：“Local search 本地搜索”。# ---------------------------------------------------------------------------------------local_search:  enable: true  # If auto, trigger search by changing input.  # If manual, trigger search by pressing enter key or search button.  # trigger 搜索触发方式，输入关键字后会触发搜索，可选 auto（自动）或 manual（手动）。  ### auto 每输入或删除一个字符后，自动触发搜索。  ### manual 每输入或删除一个字符后，需要按回车键触发搜索。  trigger: auto # values: auto | manual  # Unescape html strings to the readable one.  # # 转义 HTML 字符串为可读字符串。  unescape: false  # Preload the search data when the page loads.  # 在页面加载时预加载搜索数据。  preload: false# ---------------------------------------------------------------------------------------# Post word count# Dependencies: hexo-wordcount# See: https://github.com/willin/hexo-wordcount# 文章字数统计 &amp; 阅读时长统计# 如需启用，请先安装 Hexo 插件：hexo-wordcount。# 在博客根目录下使用 npm 命令安装: npm i hexo-wordcount --save# ---------------------------------------------------------------------------------------post_wordcount:  enable: false  wordcount: false # word count, one article  min2read: false # time to read, one article# ---------------------------------------------------------------------------------------# Home page article block display settings# 首页文章块底部的显示设置，可配置显示分类和标签。# limit 显示分类或标签的最大个数。# ---------------------------------------------------------------------------------------home_article:  category:    enable: false # show category in home page article block    limit: 3 # max number of categories shown in home page article block  tag:    enable: false # show tags in home page article block    limit: 5 # max number of tags shown in home page article block# ---------------------------------------------------------------------------------------# Code copy# 代码复制，代码块的复制风格可选 default | flat | mac。# ---------------------------------------------------------------------------------------code_copy:  enable: true  style: flat # values: default | flat | mac# ---------------------------------------------------------------------------------------# Sidebar tools# 侧边栏工具（搜索按钮、昼夜模式切换按钮、RSS按钮、TOC显示切换按钮）# ---------------------------------------------------------------------------------------side_tools:  enable: false# ---------------------------------------------------------------------------------------# Back to top# 回到顶部# ---------------------------------------------------------------------------------------back2top:  enable: false# ---------------------------------------------------------------------------------------# Table of Contents in the Sidebar# 文章目录结构# ---------------------------------------------------------------------------------------toc:  enable: false  # Automatically add list number to toc.  # 给文章目录自动加上序号。  number: true  # If true, all level of TOC in a post will be displayed, rather than the activated part of it.  # 是否展开所有目录。  expand_all: true# ---------------------------------------------------------------------------------------# Magic# magic 启用后，主题将以简约的卡片形式显示。# 可分别配置缩放效果、阴影效果。# ---------------------------------------------------------------------------------------magic:  enable: true  scale: false # scale effect when the mouse hover  shadow: false # shadow effect when the mouse hover\n\nComment 评论主题内置了 Valine 和 Gitalk 两款评论插件，你只能使用其他一款，如果两款评论插件的 enable 都设为了 true，将使用 Valine。\nValine前往 https://github.com/xCss/Valine 查看 Valine 如何使用，获取必要的参数，填写在配置文件里。\nGitalk\n在自己的 GitHub 账号下创建新的 OAuth App，链接：https://github.com/settings/applications/new ，Homepage URL 和 Authorization callback URL 均填写自己的域名即可。例 https://ils.xpoet.cn/\n在自己的 GitHub 账号下创建新的 repository 并打开 Issues，用于存储评论内容。\n把自己的 GitHub 用户名称、repository 名称 、OAuth App 的 Client ID 、Client Secret 分别填写在主题配置文件里。\n\n前往 https://github.com/gitalk/gitalk 查看 Gitalk 更多信息。\nPost top 文章顶置实现文章顶置功能，需在 Hexo 博客根目录下安装插件 **hexo-generator-index-pin-top**。\nnpm install hexo-generator-index-pin-top\n\n然后在 _posts 文件夹里的需要顶置的文章页添加 top 属性，top 值越大，顶置文章越靠前，参考如下。\n---title: 千呼万唤始出来，Hexo 主题 ILS 正式发布date: 2020-04-07 21:55:14tags: [Hexo]categories: [Hexo]top: 9999---\n\nLocal search 本地搜索\n启用本地搜索功能，需在 Hexo 博客根目录下安装插件 **hexo-generator-searchdb**。\nnpm install hexo-generator-searchdb\n\n在 Hexo 配置文件 _config.yml 增加如下配置。\n# Search## https://github.com/theme-next/hexo-generator-searchdbsearch:  path: search.json  field: post  content: true  format: striptags\n\n修改主题配置文件 _config.yml。\nlocal_search:  enable: true  trigger: auto # values: auto | manual  unescape: false  preload: true\n\n\n\nRSS 订阅\n启用 RSS 订阅功能，需先在 Hexo 博客根目录下安装插件 **hexo-generator-feed**。\nnpm install hexo-generator-feed\n\n在 Hexo 配置文件 _config.yml 增加如下配置。\n# Feed Atom# npm install hexo-generator-feedfeed:  type: atom  path: atom.xml  limit: 20\n\n修改主题配置文件 _config.yml。\nrss:  enable: true\n\n\n\nAdd page 添加页面Hexo 初始并没有 categories（分类）、about（关于）、links（友链）、tags（标签） 等页面，需要自己手动创建。\n以创建「关于」页面为例：\n\n在 Hexo 博客目录下执行命令，即可生成 about 文件夹。\nhexo new page about\n创建成功后，打开博客目录下 /source/about/index.md 文件，即可填写自己的内容。支持 Markdown 和 HTML 格式；comments: true 表示该页面开启评论功能。\n参考如下示例：\n---title: aboutdate: 2020-03-19 14:59:53comments: true---## About me- XPoet「 X 诗人 」...  ...  ...  ...\n\n在主题配置文件启用 about 导航菜单。\n# navigation menumenu:  Home: /  Archives: /archives  # Category: /category  # Links: /links  About: /about  # ...\n\n\n\n其他页面的生成方式跟「关于」页面类似，此处不再赘述。\nMathJax 数学公式如果要在文章中显示数学公式，可以使用插件 **hexo-filter-mathjax**，详情参考：https://github.com/next-theme/hexo-filter-mathjax/ 。或按下列步骤完成相关配置：\n\n在 Hexo 博客根目录下安装插件 **hexo-filter-mathjax**。\nnpm install hexo-filter-mathjax --save\n\n在 Hexo 配置文件 _config.yml 增加如下配置。\nmathjax:  tags: none # or &#x27;ams&#x27; or &#x27;all&#x27;  single_dollars: true # enable single dollar signs as in-line math delimiters  cjk_width: 0.9 # relative CJK char width  normal_width: 0.6 # relative normal (monospace) width  append_css: true # add CSS to every page  every_page: false # if true, every page will be rendered by mathjax regardless the `mathjax` setting in Front-matter of each article\n\n在文章页添加 mathjax: true，至此，就可以在该页面中写公式了。\n---title: MathJax Testdate: 2020-09-12 16:02:07tags: MathJaxcategories: MathJaxmathjax: true---$$i\\hbar\\frac&#123;\\partial&#125;&#123;\\partial t&#125;\\psi=-\\frac&#123;\\hbar^2&#125;&#123;2m&#125;\\nabla^2\\psi+V\\psi$$\n\n\n\nContribution 贡献欢迎各种形式的贡献，包括但不限于：美化样式、增加功能、改进代码、 修复 Bug 等。\nFeedback 反馈在使用该主题过程中，如果遇到问题，请仔细阅读使用文档，或者给作者提 Issue。\nLicence 许可MIT Copyright (c) 2020 XPoet\n","categories":["ILS"],"tags":["Hexo","ILS"]},{"title":"快速掌握 Vue3.0 基础语法","url":"/2020/11/%E5%BF%AB%E9%80%9F%E6%8E%8C%E6%8F%A1-Vue3.0-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/","content":"经过两年多的迭代，Vue3.0 终于在 9 月 18 日 发布了正式版，其使用 TypeScript 进行大规模重构，有着很大的改变。Vue3.0 采用 Composition API，类似 React Hook，使用更加灵活。接下来总结一下 Vue3.0 部分新特性的用法。\nVue2.x 与 Vue3.0 的对比\nVue2 对 TypeScript 支持不友好，所有属性都放在 this 对象上，难以推断出数据类型。\nVue2 大量的 API 挂载在 Vue 对象的原型上，难以实现 tree shaking。\nVue2 架构层面对跨平台 DOM 渲染开发支持不友好。\nVue3 采用 Composition API，受 React Hook 启发。\nVue3 更好地支持 JSX。\nVue3 的 Template 支持多个根标签，Vue2.x 不支持。\nVue3 对虚拟 DOM 进行了重写、对模板的编译进行了优化。\n…\n\nsetup() 函数setup() 是 Vue3.0 专门为组件提供的新属性。它为我们使用 Vue3.0 的 Composition API 新特性提供了统一的入口，setup() 在 beforeCreate() 之后和 created() 之前执行，Vue3.0 取消了这两个 2.x 版本的生命周期钩子函数，统一用 setup() 代替，该函数相当于一个生命周期函数，Vue2.x 中的 data，methods，watch 等全部都用对应的新增 API 写在 setup() 中。\nsetup(props, context) &#123;    // context.attrs    // context.slots    // context.parent    // context.root    // context.emit    // context.refs    return &#123;    &#125;  &#125;\n\n\nprops 用来接收 props 数据。\ncontext 用来定义上下文，上下文对象中包含了一些有用的属性，这些属性在 Vue2.x 中需要通过 this 才能访问到，但在 setup() 中无法访问到 this。\nreturn &#123;&#125; 返回值，返回的是响应式数据，template 模版中需要使用的函数。\n\nreactive() 函数reactive() 接收一个普通对象，返回一个响应式的数据对象，响应式数据对象创建出来之后，在 setup() 中 return 出去，即可在 template 中使用。\n&lt;template&gt; &#123;&#123; name &#125;&#125; &lt;/template&gt;&lt;script lang=&quot;ts&quot;&gt;  import &#123; defineComponent, reactive, ref, toRefs &#125; from &quot;vue&quot;;  export default defineComponent(&#123;    setup(props, context) &#123;      const person = reactive(&#123;        name: &quot;zhangsan&quot;,        age: 18,      &#125;);      return person;    &#125;,  &#125;);&lt;/script&gt;\n\nref() 函数ref() 用来根据给定的值创建一个响应式的数据对象，ref() 调用的返回值是一个对象，这个对象上只包含一个 value 属性，只在 setup() 函数内部获取 ref() 对象的值需要加上 .value。\n&lt;template&gt;  &lt;div class=&quot;mine&quot;&gt;&#123;&#123; count &#125;&#125;&lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot;&gt;  import &#123; defineComponent, ref &#125; from &quot;vue&quot;;  export default defineComponent(&#123;    setup() &#123;      const count = ref&lt;number&gt;(10);      console.log(count.value);      return &#123;        count,      &#125;;    &#125;,  &#125;);&lt;/script&gt;\n\n在 reactive() 对象中访问 ref() 创建的响应式数据对象时，不需要加 .value。\n&lt;template&gt;  &lt;div class=&quot;mine&quot;&gt;&#123;&#123; count &#125;&#125; - &#123;&#123; n &#125;&#125;&lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot;&gt;  import &#123; defineComponent, reactive, ref, toRefs &#125; from &quot;vue&quot;;  export default defineComponent(&#123;    setup() &#123;      const count = ref&lt;number&gt;(10);      const obj = reactive(&#123;        n: 100,        count,      &#125;);      // 通过 reactive 来获取 ref 的值时，不需要使用 .value 属性      console.log(obj.count); // 10      return &#123;        ...toRefs(obj),      &#125;;    &#125;,  &#125;);&lt;/script&gt;\n\nisRef() 函数isRef() 用来判断某个值是否为 ref() 创建出来的对象。\nimport &#123; defineComponent, isRef, ref &#125; from &quot;vue&quot;;export default defineComponent(&#123;  setup(props, context) &#123;    const name: string = &quot;vue&quot;;    const age = ref&lt;number&gt;(18);    console.log(isRef(age)); // true    console.log(isRef(name)); // false    return &#123;      age,      name,    &#125;;  &#125;,&#125;);\n\ntoRefs() 函数toRefs() 可以将 reactive() 创建出来的响应式对象，转换为普通的对象，这个普通对象上的每个属性节点，都是 ref() 类型的响应式数据。\n&lt;template&gt;  &lt;div class=&quot;mine&quot;&gt;&#123;&#123; name &#125;&#125; &#123;&#123; age &#125;&#125;&lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot;&gt;  import &#123; defineComponent, reactive, ref, toRefs &#125; from &quot;vue&quot;;  export default defineComponent(&#123;    setup(props, context) &#123;      const person = reactive(&#123;        name: &quot;zhangsan&quot;,      &#125;);      const age = ref(18);      return &#123;        ...toRefs(person),        age,      &#125;;    &#125;,  &#125;);&lt;/script&gt;\n\ncomputed() 函数computed() 用来创建计算属性，和前面一样，它返回的值是一个 ref() 对象。里面可以传方法，或者对象，对象中包含 set()、get() 方法。\n创建只读的计算属性import &#123; computed, defineComponent, ref &#125; from &quot;vue&quot;;export default defineComponent(&#123;  setup(props, context) &#123;    const age = ref(18);    // 根据 age 的值，创建一个响应式的计算属性 readOnlyAge，它会根据依赖的 ref 自动计算并返回一个新的 ref    const readOnlyAge = computed(() =&gt; age.value++); // 19    return &#123;      age,      readOnlyAge,    &#125;;  &#125;,&#125;);\n\n通过 set()、get() 方法创建一个可读可写的计算属性import &#123; computed, defineComponent, ref &#125; from &quot;vue&quot;;export default defineComponent(&#123;  setup(props, context) &#123;    const age = ref&lt;number&gt;(18);    const computedAge = computed(&#123;      get: () =&gt; age.value + 1,      set: (value) =&gt; age.value + value,    &#125;);    // 为计算属性赋值的操作，会触发 set 函数，触发 set 函数后，age 的值会被更新    age.value = 100;    return &#123;      age,      computedAge,    &#125;;  &#125;,&#125;);\n\nwatch() 函数watch() 用来监听特定的数据源，并在回调函数中返回。默认情况是懒执行的，仅在监听的源数据变更时才执行回调。\n监听 reactive() 创建的数据源import &#123; computed, defineComponent, reactive, toRefs, watch &#125; from &quot;vue&quot;;interface Person &#123;  name: string;  age: number;&#125;export default defineComponent(&#123;  setup(props, context) &#123;    const person = reactive&lt;Person&gt;(&#123; name: &quot;vue&quot;, age: 10 &#125;);    watch(      () =&gt; person.age,      (newValue, oldValue) =&gt; &#123;        console.log(newValue); // 100        console.log(oldValue); // 10      &#125;    );    // 修改 age 时会触发 watch 的回调，打印出改变前后的值    person.age = 100;    return &#123;      ...toRefs(person),    &#125;;  &#125;,&#125;);\n\n监听用 ref() 创建的数据源import &#123; defineComponent, ref, watch &#125; from &quot;vue&quot;;interface Person &#123;  name: string;  age: number;&#125;export default defineComponent(&#123;  setup(props, context) &#123;    const age = ref&lt;number&gt;(10);    watch(age, (oldValue, newValue) =&gt; &#123;      console.log(&quot;oldValue: &quot;, oldValue); // 10      console.log(&quot;newValue: &quot;, newValue); // 100    &#125;);    // 修改 age 时会触发 watch 的回调, 打印变更后的值    age.value = 100;    return &#123;      age,    &#125;;  &#125;,&#125;);\n\n同时监听多个值import &#123; computed, defineComponent, reactive, toRefs, watch &#125; from &quot;vue&quot;;interface Person &#123;  name: string;  age: number;&#125;export default defineComponent(&#123;  setup(props, context) &#123;    const state = reactive&lt;Person&gt;(&#123; name: &quot;zhangsan&quot;, age: 10 &#125;);    watch(      [() =&gt; state.age, () =&gt; state.name],      ([newAge, newName], [oldAge, oldName]) =&gt; &#123;        console.log(newAge);        console.log(newName);        console.log(oldAge);        console.log(oldName);      &#125;    );    // 修改 state 时会触发 watch 的回调，打印变更前后的值，此时需要注意，更改其中一个值，都会执行 watch 的回调    state.age = 100;    state.name = &quot;lisi&quot;;    return &#123;      ...toRefs(state),    &#125;;  &#125;,&#125;);\n\nstop 停止监听在 setup() 内创建的 watch() 监视，会在当前组件被销毁的时候自动停止。如果想要明确地停止某个监听，可以调用 watch() 的返回值即可。\nimport &#123; computed, defineComponent, reactive, toRefs, watch &#125; from &quot;vue&quot;;interface Person &#123;  name: string;  age: number;&#125;export default defineComponent(&#123;  setup(props, context) &#123;    const state = reactive&lt;Person&gt;(&#123; name: &quot;zhangsan&quot;, age: 10 &#125;);    const stop = watch(      [() =&gt; state.age, () =&gt; state.name],      ([newAge, newName], [oldAge, oldName]) =&gt; &#123;        console.log(newAge);        console.log(newName);        console.log(oldAge);        console.log(oldName);      &#125;    );    state.age = 100;    state.name = &quot;lisi&quot;;    setTimeout(() =&gt; &#123;      stop();      // 此时修改时, 不会触发 watch 回调      state.age = 1000;      state.name = &quot;wangwu&quot;;    &#125;, 1000); // 1秒之后讲取消watch的监听    return &#123;      ...toRefs(state),    &#125;;  &#125;,&#125;);\n\nLifeCycle Hooks 新的生命周期函数import &#123;  defineComponent,  onBeforeMount,  onBeforeUnmount,  onBeforeUpdate,  onErrorCaptured,  onMounted,  onUnmounted,  onUpdated,&#125; from &quot;vue&quot;;export default defineComponent(&#123;  setup(props, context) &#123;    onBeforeMount(() =&gt; &#123;      console.log(&quot;beformounted!&quot;);    &#125;);    onMounted(() =&gt; &#123;      console.log(&quot;mounted!&quot;);    &#125;);    onBeforeUpdate(() =&gt; &#123;      console.log(&quot;beforupdated!&quot;);    &#125;);    onUpdated(() =&gt; &#123;      console.log(&quot;updated!&quot;);    &#125;);    onBeforeUnmount(() =&gt; &#123;      console.log(&quot;beforunmounted!&quot;);    &#125;);    onUnmounted(() =&gt; &#123;      console.log(&quot;unmounted!&quot;);    &#125;);    onErrorCaptured(() =&gt; &#123;      console.log(&quot;errorCaptured!&quot;);    &#125;);    return &#123;&#125;;  &#125;,&#125;);\n\nTemplate refs通过 refs 来返回真实 DOM 元素，为了获得对模板内元素或组件实例的引用，我们可以在 setup() 中声明一个 ref() 并返回它。\n\n在 HTML 添加 ref 的属性。\n在 steup() 中定义一个 ref()。\n在 steup() 中返回 ref() 的实例.\nonMounted() 中可以得到 ref() 的 RefImpl 的对象, 通过 .value 获取真实 DOM。\n\n&lt;template&gt;  &lt;div ref=&quot;elmRefs&quot;&gt;    &lt;span&gt;test&lt;/span&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot;&gt;  import &#123; defineComponent, onMounted, ref &#125; from &quot;vue&quot;;  export default defineComponent(&#123;    setup(props, context) &#123;      // 获取真实DOM      const elmRefs = ref&lt;null | HTMLElement&gt;(null);      onMounted(() =&gt; &#123;        console.log(elmRefs.value); // 得到一个 RefImpl 的对象, 通过 .value 访问到数据      &#125;);      return &#123;        elmRefs,      &#125;;    &#125;,  &#125;);&lt;/script&gt;\n\nVue3 全局配置通过 Vue 实例上 config 来配置，包含 Vue 应用程序全局配置的对象。在挂载应用程序之前修改下面列出的属性。\nconst app = Vue.createApp(&#123;&#125;)app.config = &#123;...&#125;\n\n为组件渲染功能和观察程序期间的未捕获错误分配处理程序\napp.config.errorHandler = (err, vm, info) =&gt; &#123;&#125;;\n\n可以在应用程序内的任何组件实例中访问的全局属性，组件的属性将具有优先权。这可以代替 Vue2.x Vue.prototype 扩展。\nimport axios from &quot;axios&quot;;const app = Vue.createApp(&#123;&#125;);app.config.globalProperties.$http = axios;\n\n可以在组件内通过 getCurrentInstance() 来获取全局 globalProperties 中配置的信息，getCurrentInstance() 获取当前组件的实例，然后通过 ctx 属性获得当前上下文，这样我们就能在 setup() 中使用 router 和 vuex，通过这个属性我们就可以操作变量、全局属性、组件属性等等。\nsetup() &#123;  const &#123; ctx &#125; = getCurrentInstance();  // ctx.$http&#125;\n\nSuspense 组件在介绍 Vue 的 Suspense 组件之前，我们有必要先了解一下 React 的 Suspense 组件，因为它们的功能类似。React.lazy 接受一个函数，这个函数需要动态调用 import()。它必须返回一个 Promise，该 Promise 需要 resolve 一个 default export 的 React 组件。\nimport React, &#123; Suspense &#125; from &quot;react&quot;;const myComponent = React.lazy(() =&gt; import(&quot;./Component&quot;));function MyComponent() &#123;  return (    &lt;div&gt;      &lt;Suspense fallback=&#123;&lt;div&gt;Loading...&lt;/div&gt;&#125;&gt;        &lt;myComponent /&gt;      &lt;/Suspense&gt;    &lt;/div&gt;  );&#125;\n\nVue3 也新增了 React.lazy 类似功能的 defineAsyncComponent 函数，处理动态引入的组件。defineAsyncComponent 可以接受返回 Promise 的工厂函数。从服务器检索到组件定义时，应该调用 Promise 的解析回调。您还可以调用 reject(reason) 来指示负载已经失败。\nimport &#123; defineAsyncComponent &#125; from &quot;vue&quot;;const AsyncComp = defineAsyncComponent(  () =&gt; import(&quot;./components/AsyncComponent.vue&quot;));app.component(&quot;async-component&quot;, AsyncComp);\n\nVue3 也新增了 Suspense 组件:\n&lt;template&gt;  &lt;Suspense&gt;    &lt;template #default&gt;      &lt;my-component /&gt;    &lt;/template&gt;    &lt;template #fallback&gt; Loading ... &lt;/template&gt;  &lt;/Suspense&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot;&gt;  import &#123; defineComponent, defineAsyncComponent &#125; from &quot;vue&quot;;  const MyComponent = defineAsyncComponent(() =&gt; import(&quot;./Component&quot;));  export default defineComponent(&#123;    components: &#123;      MyComponent,    &#125;,    setup() &#123;      return &#123;&#125;;    &#125;,  &#125;);&lt;/script&gt;\n","categories":["前端"],"tags":["Vue3"]},{"title":"快速掌握 Markdown 基础语法","url":"/2017/10/%E5%BF%AB%E9%80%9F%E6%8E%8C%E6%8F%A1Markdown%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/","content":"什么是 MarkdownMarkdown 是一种「轻量级标记语言」，用途广泛，其使用简洁的语法代替常见的排版格式，从而能使我们专心于写作，在最大程度上提高效率。Markdown 的语法十分简单，常用的标记符号也不超过十个，学习成本极低，一旦熟悉这种语法规则，将会有一劳永逸的效果。  \n\nWe believe that writing is about content, about what you want to say – not about fancy formatting.我们坚信写作写的是内容，所思所想，而不是花样格式。\n\n使用 Markdown 的优点\n专注你的文字内容而不是排版样式；\n纯文本内容，兼容所有的文本编辑器；\n可读、直观、通用性高、学习成本低；  \n轻松导出 HTML 、PDF 等格式的文件；  \n随时可修改 .md 文件，不会因版本问题导致格式混乱；\n\nMarkdown 语法规则标题标记符 #标题是文章最常用的格式，在 Markdown 中，如果一段文字被定义为标题，只需在这段文字前加 # 标记符。例如：# 一级标题## 二级标题### 三级标题……以此类推，共六级标题，对应 HTML 的 h1 ~ h6。注意：# 和文字之间需加一个空格。\n \n字体加粗标记符 ** 或 __在需要表示为粗体的文字内容，用两个 ** 或 __ 标记符包裹。例如：**字体加粗** 或 __字体加粗__\n \n斜体标记符 * 或 _在需要表示为斜体的文字内容，用两个 * 或 _ 标记符包裹。例如：*斜体* 或 _斜体_\n \n引用标记符 &gt;只需在引用的文字内容前面加上 &gt; 标记符，就可以出现引用的效果。例如：&gt; 我是引用的句子哦\n\n列表无序列表标记符 - 或 + 或 *在需要表示为无序列表的文字前加 - 或 + 或 * 标记符。\n\n有序列表标记符 1. 或 2. 或 3. ……在需要表示为有序列表的文字前面添加加 1. 或 2. 或 3. …… 标记符。\n  \n链接标记符 []()在 Markdown 中，插入链接，例如：[XPoet Blog](https://xtpoet.cn)\n\n图片标记符 ![]()图片示例：![aliyun](https://img.alicdn.com/tfs/TB1Ly5oS3HqK1RjSZFPXXcwapXa-238-54.png)\n\n代码单行代码标记符 `  `需要引用代码时，如果引用的代码只有一行，可以用两个 ` 标记符将代码包裹起来。例如：\n\n多行代码标记符：```  ```多行代码，用两个 ``` 标记符将代码块包裹起来。例如：\n\n分割线标记符：*** 或 --- 或 ___插入分割线，在一行中用三个以上的 * 或 - 或 _ 标记符来建立一个分隔线，行内不能有其他内容，分隔符独占一行。\n删除线标记符：~~在需要添加删除线的文字内容，用两个 ~~ 标记符包裹。例如：~~ABC~~ ABC\n换行标记符： 两个空格符 加 回车在 Markdown 中进行换行，需在文字后面键入 两个空格符 加 回车。\n表格在 Markdown 中插入表格的标记符比较复杂，大家直接看效果，需要用到时过来复制代码。\n默认表格样式参考代码：\nColName1 | ColName2 | ColName3---------|----------|---------ColValue | ColValue | ColValueColValue | ColValue | ColValueColValue | ColValue | ColValueColValue | ColValue | ColValue\n\n效果如下：\n\n\n\nColName1\nColName2\nColName3\n\n\n\nColValue\nColValue\nColValue\n\n\nColValue\nColValue\nColValue\n\n\nColValue\nColValue\nColValue\n\n\nColValue\nColValue\nColValue\n\n\n表格列调整表格的列位置调整（默认左对齐，:------: 居中，------: 右对齐）参考代码：\n|ColName1 | ColName2 | ColName3||---------|:--------:|--------:||ColValue | ColValue | ColValue||ColValue | ColValue | ColValue||ColValue | ColValue | ColValue||ColValue | ColValue | ColValue|\n\n效果如下：\n\n\n\nColName1\nColName2\nColName3\n\n\n\nColValue\nColValue\nColValue\n\n\nColValue\nColValue\nColValue\n\n\nColValue\nColValue\nColValue\n\n\nColValue\nColValue\nColValue\n\n\n由于不同平台的 Markdown CSS 存在差异，实际显示效果跟本文也会有所不同。\n","categories":["技术教程"],"tags":["Markdown"]},{"title":"触动心灵的六句古诗词","url":"/2017/10/%E8%A7%A6%E5%8A%A8%E5%BF%83%E7%81%B5%E7%9A%84%E5%85%AD%E5%8F%A5%E5%8F%A4%E8%AF%97%E8%AF%8D/","content":"\n人生若只如初见，何事秋风悲画扇。 ——纳兰性德 《木兰词·拟古决绝词柬友》\n\n很多时候，初见，惊艳。蓦然回首，却已是物是人非，曾经沧海，只怕早已换了桑田。短短的一句话，道尽人生多少悲凉，道尽人生多少无奈。如果所有往事都能化为红尘一笑，只留下初见时的倾情、惊艳，忘却也许有过的背叛、伤怀，这是何等美妙的人生境界。若只是初见，一切美好都不会遗失。  \n\n曾经沧海难为水，除却巫山不是云。 ——元稹 《离思（其四）》\n\n曾读此诗难为诗，因为这句诗把人对某种生死之恋的刻骨铭心写绝了。在记忆之海里继续沉浸，在往事里打捞沉落的星辰月光，直至那昔年的沧海也将自己渐渐淹没。难道真的是沧海巫山之后，便再无水和云了？所以，不要太早遇见心上的他/她，万一你捉不住他/她，将一辈子都活在这句诗句里。  \n\n人面不知何处去，桃花依旧笑春风。 ——崔护 《题都城南庄》\n\n心爱的人不知道去哪了？只留下桃花却依然微笑，在春风中绽放。以笑映悲，道尽心中悲楚，令人不禁感慨万千。若干年后，我们是否也会有如此遭遇呢？  \n\n众里寻她千百度，蓦然回首，那人却在，灯火阑珊处。 ——辛弃疾 《青玉案·元夕》\n\n我千百次寻找，等待的那个人还没有出现。我的心充满疲惫和失落，不经意一回首，却发现她就在那灯火寥落的地方静静地站着。很多时候，我们总是在往阴暗处去寻找我们心中的她，却总不见其影踪，蓦然回首，才发现她其实一直就在我们的身边，离我们只有一个转身的距离。  \n\n衣带渐宽终不悔，为伊消得人憔悴。 ——柳永 《蝶恋花》\n\n无可替代的思念，无怨无悔的执着，脸庞的瘦削，颧骨的高突，身上的青衫也变得宽松了，但从没有后悔这一切皆因对她无边的思念而起，心甘情愿为爱饱受煎熬。这无尽的思念、无尽的爱，人世间又有谁能承受的起呢？   \n\n纵使相逢应不识，尘满面，鬓如霜。 ——苏轼 《江城子·乙卯正月二十日夜记梦》\n\n即使相逢也料想不会认识，因为我四处奔波，灰尘满面，鬓发如霜。这恐怕是每个一人最害怕的结果，若是不见也就罢了，若是相见，却互不认识，就这样在岁月里蹉跎地擦肩而过，那该是多么令人心碎的一幕。  \n后记： 沧海桑田，浩瀚的历史长河中，触动我心灵的古诗词又怎么可能只有这六句呢？\n","categories":["诗词人生"],"tags":["诗词"]},{"title":"醉眼天涯 花香满衣","url":"/2017/10/%E9%86%89%E7%9C%BC%E5%A4%A9%E6%B6%AF-%E8%8A%B1%E9%A6%99%E6%BB%A1%E8%A1%A3/","content":"在忽然惊醒的夜凉里，挨着秋天的衣袖，独坐如莲。灯半笼，更阑。\n夜雾已经烹煮成一壶茶，不饮。相思已经倾斜成箫，不吹。只在梦的边缘，等你叩门的绝响。\n我的思念，是你前世遗忘采撷而无法成熟的青果。不舍那未了的情缘，我才执意轮回世间。单薄的形骸幻化成一树瘦梅，等你在必经的路旁。依旧是前世那一袭清绝的白衣，期待成为你不期而至的风景。拥有你一刻完整凝眸，即便错失整个花季，我也欣然坠落，腐化为泥。是什么将我的回眸捂上？烟色的记忆里，总不见你寻路而来，陪我，垂钓月光。\n洪荒的纪事已远，恍若隔世的约定风一般不着形迹，最放心不下的，还是你。为你点燃的浣花诗灯一盏一盏次第而亮，为你酝酿的柔情千顷一寸一寸绿满天涯。\n三界内，所有的花树静静的迎候岁月，唯我轻衫飘飘、暗香盈盈，等你在岁月的对岸。你不来，我不敢老去。静夜里如此的思念，真的会把你惊醒?\n今夜，你终于顺着长长的夜路，踏响我长满青苔的小径。苔痕斑驳的门扉，洞箫细碎的长廊,有谁的心事穿袜行走，莲步轻移。\n握着你的一唇冰凉，隔世的故事碎玉满地。心疼你单衣试酒的落寞孤寒，为你一弦独操，陪你独立霜降的寒凉。用素帕细细为你抹去肩头发上的霜，拢你的一袖寒凉……\n剪烛西窗。一卷心情，一壶淡酒，一阙宫商。单薄的素衣，不耐乍暖还寒的雨季。此刻，你停泊在哪一隅的夜凉里？\n谁替你烘干夜露沾湿的薄衫，笑你花香满衣。谁如我前世一般卷帘相问：可看见月的香馨？何处是港湾？青山麓，碧水旁，黄昏沙滩？寂寞沙洲寒。\n空相对，远山，远水……残红，无寐……  \n","categories":["诗词人生"],"tags":["诗词"]},{"title":"JavaScript 数据结构与算法（五）单向链表结构","url":"/2020/07/JavaScript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%94%EF%BC%89%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8%E7%BB%93%E6%9E%84/","content":"认识链表链表和数组链表和数组一样，可以用于存储一系列的元素，但是链表和数组的实现机制完全不同。\n数组\n存储多个元素，数组（或列表）可能是最常用的数据结构。\n\n几乎每一种编程语言都有默认实现数组结构，提供了一个便利的 [] 语法来访问数组元素。\n\n数组缺点：\n数组的创建需要申请一段连续的内存空间(一整块内存)，并且大小是固定的，当前数组不能满足容量需求时，需要扩容。 (一般情况下是申请一个更大的数组，比如 2 倍，然后将原数组中的元素复制过去)\n在数组开头或中间位置插入数据的成本很高，需要进行大量元素的位移。\n\n\n链表\n存储多个元素，另外一个选择就是使用链表。\n\n不同于数组，链表中的元素在内存中不必是连续的空间。\n\n链表的每个元素由一个存储元素本身的节点和一个指向下一个元素的引用(有些语言称为指针)组成。\n\n链表优点：\n内存空间不必是连续的，可以充分利用计算机的内存，实现灵活的内存动态管理。\n链表不必在创建时就确定大小，并且大小可以无限延伸下去。\n链表在插入和删除数据时，时间复杂度可以达到 O(1)，相对数组效率高很多。\n\n链表缺点：\n访问任何一个位置的元素时，需要从头开始访问。(无法跳过第一个元素访问任何一个元素)\n无法通过下标值直接访问元素，需要从头开始一个个访问，直到找到对应的元素。\n虽然可以轻松地到达下一个节点，但是回到前一个节点是很难的。\n\n\n单向链表单向链表类似于火车，有一个火车头，火车头会连接一个节点，节点上有乘客，并且这个节点会连接下一个节点，以此类推。\n\n链表的火车结构\n\n\n链表的数据结构\nhead 属性指向链表的第一个节点。链表中的最后一个节点指向 null。当链表中一个节点也没有的时候，head 直接指向 null。\n\n\n给火车加上数据后的结构\n\n\n\n链表中的常见操作\nappend(element) 向链表尾部添加一个新的项。\ninsert(position, element) 向链表的特定位置插入一个新的项。\nget(position) 获取对应位置的元素。\nindexOf(element) 返回元素在链表中的索引。如果链表中没有该元素就返回-1。\nupdate(position, element) 修改某个位置的元素。\nremoveAt(position) 从链表的特定位置移除一项。\nremove(element) 从链表中移除一项。\nisEmpty() 如果链表中不包含任何元素，返回 trun，如果链表长度大于 0 则返回 false。\nsize() 返回链表包含的元素个数，与数组的 length 属性类似。\ntoString() 由于链表项使用了 Node 类，就需要重写继承自 JavaScript 对象默认的 toString 方法，让其只输出元素的值。\n\n单向链表的封装创建单向链表类先创建单向链表类 LinkedList，添加基本属性，再逐步实现单向链表的常用方法。\nclass LinkedList &#123;  // 初始链表长度为 0  length = 0;  // 初始 head 为 null，head 指向链表的第一个节点  head = null;  // 内部类（链表里的节点 Node）  Node = class &#123;    data;    next = null;    constructor(data) &#123;      this.data = data;    &#125;  &#125;;&#125;\n\n实现 append() 方法代码实现// append() 往链表尾部追加数据append(data) &#123;    // 1、创建新节点    const newNode = new this.Node(data);    // 2、追加新节点    if (this.length === 0) &#123;    // 链表长度为 0 时，即只有 head 的时候    this.head = newNode;    &#125; else &#123;    // 链表长度大于 0 时，在最后面添加新节点    let currentNode = this.head;    // 当 currentNode.next 不为空时，    // 循序依次找最后一个节点，即节点的 next 为 null 时    while (currentNode.next !== null) &#123;        currentNode = currentNode.next;    &#125;    // 最后一个节点的 next 指向新节点    currentNode.next = newNode;    &#125;    // 3、追加完新节点后，链表长度 + 1    this.length++;&#125;\n\n过程图解\n首先让 currentNode 指向第一个节点。\n\n\n通过 while 循环使 currentNode 指向最后一个节点，最后通过 currentNode.next = newNode，让最后一个节点指向新节点 newNode。\n\n\n\n代码测试const linkedList = new LinkedList();// 测试 append 方法linkedList.append(&quot;A&quot;);linkedList.append(&quot;B&quot;);linkedList.append(&quot;C&quot;);console.log(linkedList);\n\n\n实现 toString() 方法代码实现toString() &#123;    let currentNode = this.head;    let result = &#x27;&#x27;;    // 遍历所有的节点，拼接为字符串，直到节点为 null    while (currentNode) &#123;    result += currentNode.data + &#x27; &#x27;;    currentNode = currentNode.next;    &#125;    return result;&#125;\n\n代码测试// 测试 toString 方法console.log(linkedList.toString()); //--&gt; AA BB CC\n\n实现 insert() 方法代码实现// insert() 在指定位置（position）插入节点insert(position, data) &#123;    // position 新插入节点的位置    // position = 0 表示新插入后是第一个节点    // position = 1 表示新插入后是第二个节点，以此类推    // 1、对 position 进行越界判断，不能小于 0 或大于链表长度    if (position &lt; 0 || position &gt; this.length) return false;    // 2、创建新节点    const newNode = new this.Node(data);    // 3、插入节点    if (position === 0) &#123; // position = 0 的情况    // 让新节点的 next 指向 原来的第一个节点，即 head    newNode.next = this.head;    // head 赋值为 newNode    this.head = newNode;    &#125; else &#123; // 0 &lt; position &lt;= length 的情况    // 初始化一些变量    let currentNode = this.head; // 当前节点初始化为 head    let previousNode = null; // head 的 上一节点为 null    let index = 0; // head 的 index 为 0    // 在 0 ~ position 之间遍历，不断地更新 currentNode 和 previousNode    // 直到找到要插入的位置    while (index++ &lt; position) &#123;        previousNode = currentNode;        currentNode = currentNode.next;    &#125;    // 在当前节点和当前节点的上一节点之间插入新节点，即它们的改变指向    newNode.next = currentNode;    previousNode.next = newNode;    &#125;    // 更新链表长度    this.length++;    return newNode;&#125;\n\n代码测试// 测试 insert 方法linkedList.insert(0, &quot;123&quot;);linkedList.insert(2, &quot;456&quot;);console.log(linkedList.toString()); //--&gt; 123 AA 456 BB CC\n\n实现 getData() 方法获取指定位置（position）的 data。\n代码实现getData(position) &#123;    // 1、position 越界判断    if (position &lt; 0 || position &gt;= this.length) return null;    // 2、获取指定 position 节点的 data    let currentNode = this.head;    let index = 0;    while (index++ &lt; position) &#123;    currentNode = currentNode.next;    &#125;    // 3、返回 data    return currentNode.data;&#125;\n\n代码测试// 测试 getData 方法console.log(linkedList.getData(0)); //--&gt; 123console.log(linkedList.getData(1)); //--&gt; AA\n\n实现 indexOf() 方法indexOf(data) 返回指定 data 的 index，如果没有，返回 -1。\n代码实现indexOf(data) &#123;    let currentNode = this.head;    let index = 0;    while (currentNode) &#123;    if (currentNode.data === data) &#123;        return index;    &#125;    currentNode = currentNode.next;    index++;    &#125;    return -1;&#125;\n\n代码测试// 测试 indexOf 方法console.log(linkedList.indexOf(&quot;AA&quot;)); //--&gt; 1console.log(linkedList.indexOf(&quot;ABC&quot;)); //--&gt; -1\n\n实现 update() 方法update(position, data) 修改指定位置节点的 data。\n代码实现update(position, data) &#123;    // 涉及到 position 都要进行越界判断    // 1、position 越界判断    if (position &lt; 0 || position &gt;= this.length) return false;    // 2、痛过循环遍历，找到指定 position 的节点    let currentNode = this.head;    let index = 0;    while (index++ &lt; position) &#123;    currentNode = currentNode.next;    &#125;    // 3、修改节点 data    currentNode.data = data;    return currentNode;&#125;\n\n代码测试// 测试 update 方法linkedList.update(0, &quot;12345&quot;);console.log(linkedList.toString()); //--&gt; 12345 AA 456 BB CClinkedList.update(1, &quot;54321&quot;);console.log(linkedList.toString()); //--&gt; 12345 54321 456 BB CC\n\n实现 removeAt() 方法removeAt(position) 删除指定位置的节点。\n代码实现removeAt(position) &#123;    // 1、position 越界判断    if (position &lt; 0 || position &gt;= this.length) return null;    // 2、删除指定 position 节点    let currentNode = this.head;    if (position === 0) &#123;    // position = 0 的情况    this.head = this.head.next;    &#125; else &#123;    // position &gt; 0 的情况    // 通过循环遍历，找到指定 position 的节点，赋值到 currentNode    let previousNode = null;    let index = 0;    while (index++ &lt; position) &#123;        previousNode = currentNode;        currentNode = currentNode.next;    &#125;    // 巧妙之处，让上一节点的 next 指向到当前的节点的 next，相当于删除了当前节点。    previousNode.next = currentNode.next;    &#125;    // 3、更新链表长度 -1    this.length--;    return currentNode;&#125;\n\n代码测试// 测试 removeAt 方法linkedList.removeAt(3);console.log(linkedList.toString()); //--&gt; 12345 54321 456 CC\n\n实现 remove() 方法remove(data) 删除指定 data 所在的节点。\n代码实现remove(data) &#123;    this.removeAt(this.indexOf(data));&#125;\n\n代码测试// 测试 remove 方法linkedList.remove(&quot;CC&quot;);console.log(linkedList.toString()); //--&gt; 12345 54321 456\n\n实现 isEmpty() 方法isEmpty() 判断链表是否为空。\n代码实现isEmpty() &#123;    return this.length === 0;&#125;\n\n代码测试// 测试 isEmpty 方法console.log(linkedList.isEmpty()); //--&gt; false\n\n实现 size() 方法size() 获取链表的长度。\n代码实现size() &#123;    return this.length;&#125;\n\n代码测试// 测试 size 方法console.log(linkedList.size()); //--&gt; 3\n\n完整实现class LinkedList &#123;  // 初始链表长度为 0  length = 0;  // 初始 head 为 null，head 指向链表的第一个节点  head = null;  // 内部类（链表里的节点 Node）  Node = class &#123;    data;    next = null;    constructor(data) &#123;      this.data = data;    &#125;  &#125;;  // ------------ 链表的常见操作 ------------ //  // append() 往链表尾部追加数据  append(data) &#123;    // 1、创建新节点    const newNode = new this.Node(data);    // 2、追加新节点    if (this.length === 0) &#123;      // 链表长度为 0 时，即只有 head 的时候      this.head = newNode;    &#125; else &#123;      // 链表长度大于 0 时，在最后面添加新节点      let currentNode = this.head;      // 当 currentNode.next 不为空时，      // 循序依次找最后一个节点，即节点的 next 为 null 时      while (currentNode.next !== null) &#123;        currentNode = currentNode.next;      &#125;      // 最后一个节点的 next 指向新节点      currentNode.next = newNode;    &#125;    // 3、追加完新节点后，链表长度 + 1    this.length++;  &#125;  // insert() 在指定位置（position）插入节点  insert(position, data) &#123;    // position 新插入节点的位置    // position = 0 表示新插入后是第一个节点    // position = 1 表示新插入后是第二个节点，以此类推    // 1、对 position 进行越界判断，不能小于 0 或大于链表长度    if (position &lt; 0 || position &gt; this.length) return false;    // 2、创建新节点    const newNode = new this.Node(data);    // 3、插入节点    if (position === 0) &#123;      // position = 0 的情况      // 让新节点的 next 指向 原来的第一个节点，即 head      newNode.next = this.head;      // head 赋值为 newNode      this.head = newNode;    &#125; else &#123;      // 0 &lt; position &lt;= length 的情况      // 初始化一些变量      let currentNode = this.head; // 当前节点初始化为 head      let previousNode = null; // head 的 上一节点为 null      let index = 0; // head 的 index 为 0      // 在 0 ~ position 之间遍历，不断地更新 currentNode 和 previousNode      // 直到找到要插入的位置      while (index++ &lt; position) &#123;        previousNode = currentNode;        currentNode = currentNode.next;      &#125;      // 在当前节点和当前节点的上一节点之间插入新节点，即它们的改变指向      newNode.next = currentNode;      previousNode.next = newNode;    &#125;    // 更新链表长度    this.length++;    return newNode;  &#125;  // getData() 获取指定位置的 data  getData(position) &#123;    // 1、position 越界判断    if (position &lt; 0 || position &gt;= this.length) return null;    // 2、获取指定 position 节点的 data    let currentNode = this.head;    let index = 0;    while (index++ &lt; position) &#123;      currentNode = currentNode.next;    &#125;    // 3、返回 data    return currentNode.data;  &#125;  // indexOf() 返回指定 data 的 index，如果没有，返回 -1。  indexOf(data) &#123;    let currentNode = this.head;    let index = 0;    while (currentNode) &#123;      if (currentNode.data === data) &#123;        return index;      &#125;      currentNode = currentNode.next;      index++;    &#125;    return -1;  &#125;  // update() 修改指定位置节点的 data  update(position, data) &#123;    // 涉及到 position 都要进行越界判断    // 1、position 越界判断    if (position &lt; 0 || position &gt;= this.length) return false;    // 2、痛过循环遍历，找到指定 position 的节点    let currentNode = this.head;    let index = 0;    while (index++ &lt; position) &#123;      currentNode = currentNode.next;    &#125;    // 3、修改节点 data    currentNode.data = data;    return currentNode;  &#125;  // removeAt() 删除指定位置的节点  removeAt(position) &#123;    // 1、position 越界判断    if (position &lt; 0 || position &gt;= this.length) return null;    // 2、删除指定 position 节点    let currentNode = this.head;    if (position === 0) &#123;      // position = 0 的情况      this.head = this.head.next;    &#125; else &#123;      // position &gt; 0 的情况      // 通过循环遍历，找到指定 position 的节点，赋值到 currentNode      let previousNode = null;      let index = 0;      while (index++ &lt; position) &#123;        previousNode = currentNode;        currentNode = currentNode.next;      &#125;      // 巧妙之处，让上一节点的 next 指向到当前的节点的 next，相当于删除了当前节点。      previousNode.next = currentNode.next;    &#125;    // 3、更新链表长度 -1    this.length--;    return currentNode;  &#125;  // remove() 删除指定 data 的节点  remove(data) &#123;    this.removeAt(this.indexOf(data));  &#125;  // isEmpty() 判断链表是否为空  isEmpty() &#123;    return this.length === 0;  &#125;  // size() 获取链表的长度  size() &#123;    return this.length;  &#125;  // toString() 链表数据以字符串形式返回  toString() &#123;    let currentNode = this.head;    let result = &quot;&quot;;    // 遍历所有的节点，拼接为字符串，直到节点为 null    while (currentNode) &#123;      result += currentNode.data + &quot; &quot;;      currentNode = currentNode.next;    &#125;    return result;  &#125;&#125;\n","categories":["算法专辑"],"tags":["JavaScript","数据结构","算法","单向链表"]}]